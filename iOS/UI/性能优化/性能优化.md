# 性能及卡顿优化

> 性能优化是多方面的，也是非常细节的。最直观的就是用户交互的卡顿优化（UITableView流畅度优化）;也有应用业务处理能力和极限的优化（例如，即时消息应用在收到大批量离线消息处理，入库以及展示的优化；附件消息下载优化，优先级策略调整）；还有应用启动的优化（耗时操作的异步，推迟非必要的初始化）

## 屏幕显示图像的原理

> 屏幕显示的画面是由电子枪扫描一行一行的显示的；当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号(HSync); 当一帧画面显示完成后，电子枪复位，准备下一帧前，显示器会发出一个垂直同步信号(VSync)。显示器通常以固定的频率刷新，这个频率就是垂直同步信号产生的频率。

![屏幕显像原理][1]

> 如上图所示，计算机系统中 CPU、GPU、显示器是以上面这种方式协同工作的。CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。

> 为了解决效率问题，通常会引入两个缓冲区，即双缓冲机制；在这种情况下，GPU 会预先渲染好一帧放入一个缓冲区内，让视频控制器读取，当下一帧渲染好后，GPU 会直接把视频控制器的指针指向第二个缓冲器。如此一来效率会有很大的提升；但是因此会引入画面撕裂的问题，如下图。

![画面撕裂][2]

> 为了解决画面撕裂，，GPU 通常有一个机制叫做垂直同步（简写也是 V-Sync），当开启垂直同步后，GPU 会等待显示器的 VSync 信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。

## 卡顿产生的原因

> 在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。

> CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。

## CPU 的主要工作

> 除了与UI相关的布局计算以及绘制，CPU同时还会处理各种计算，也会被IO操作和网络请求影响。首先应该避免耗时操作(如网络请求，耗时计算或者过多的IO操作)在主线程的执行，

### 对象的创建

> 对象的创建会分配内存，调整属性，甚至还会有IO操作，比较消耗CPU资源。

- 用轻量级对象代替重量级对象(在不涉及触摸事件时，由CALayer代替UIView)

- 不涉及UI的操作放到后台线程去

- 推迟和分散对象创建的时间(不要在同一段时间内创建过多或者暂时用不上的对象，推迟到必须时才创建；如一个自定义视图的子视图，没有必要在父视图创建的同时立马创建)

- 实现对象的复用(创建缓存复用对象，如UITableViewCell的复用机制)


### 对象的销毁

> 对象的销毁一般来说不会消耗太多时间和资源；但是现在都是使用ARC，如果在一次事件循环中，积累了大量需要销毁的对象，还是会引起卡顿的





[1]: 屏幕显像原理.png
[2]: ios_vsync_off.jpg
