# 中断，异常以及系统调用

## 1. 定义

- 系统调用(来源于应用程序)： 应用程序主动向系统发出的服务请求。

      计算机中操作系统内核是可以被信赖的第三方软件，
      可以管理计算机硬件和所有的计算机指令； 
      
      而应用程序是不被信任的，处于用户态，只能执行部分的指令；

      因此想要访问硬件资源和执行特权指令，必须通过系统调用陷入内核。
      
      这既是安全的考虑，也是为应用程序提供友好的请求资源的接口

- 异常(来源于不良的应用程序)： 非法指令或者其他坏的状态

- 中断(来源于外设)：来自硬件设备的请求

## 2. 差异

- 来源
    
    - 系统调用(来源于应用程序)
    - 异常(来源于不良的应用程序)
    - 中断(来源于外设)

- 处理时间
   
   - 系统调用： 异步或同步
   - 异常： 同步
   - 中断： 异步
    
- 响应处理

   - 中断： 持续，对用户程序来说是透明的
   - 异常： 杀死或者重新执行出现异常的指令
   - 系统调用： 

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2020-10-10%20%E4%B8%8A%E5%8D%886.59.27.png)

## 3. 中断处理机制

系统中，中断向量表维护了中断标记和中断处理例程的映射

- 硬件设置中断标记[CPU初始化]
   
    - 依据内部和外部事件设置中断标记
    - 中断事件的ID

- 软件 

    - 保存当前程序执行的现场
    - 执行中断服务例程
    - 清除中断标记
    - 恢复之前的程序

## 4. 异常处理机制

用户程序执行过程中出现异常，生成一个异常编号

- 保存程序执行的现场
- 异常处理
    
    - 杀死产生异常的程序
    - 重新执行程序

- 恢复程序执行的现场

## 5. 系统调用

### 5.1 系统调用的实现

- 每个系统调用对应一个系统调用号

    系统调用表维护了系统调用号和相应的系统调用实现的地址

- 系统调用接口调用内核态中系统调用功能实现，并返回系统调用的状态和结果
    
### 5.2 系统调用和函数调用的区别

- 系统调用会从用户态转为内核态，函数调用没有

- 内核态有独立的堆栈，系统调用会触发堆栈的切换


## 6. 系统调用，中断以及异常的开销

系统调用，中断以及异常在执行时间上开销超过函数调用

- 需要建立中断/异常/系统调用编号与对应服务例程的映射表

- 内核态有独立的堆栈（切换到内核态需要切换堆栈）

- 系统调用会检查参数

- 内核态映射到用户态的地址空间

- 内核态独立地址空间


       
         




 


          
          