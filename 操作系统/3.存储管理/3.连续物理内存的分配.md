# 连续物理内存的分配

## 1. 内存碎片

**内存碎片**：在内存分配中产生的无法被利用的内存

- 外部碎片
   
      分配单元之间的碎片
    
- 内部碎片

      分配单元中的碎片


## 2. 分区的动态分配

当程序被加载进内存和程序在执行过程中，操作系统都要为程序分配连续的内存空间。

操作系统需要维护的数据结构：
- 所有进程的已分配分区
- 空闲的分区

三个基本的内存分配策略：

- 首次适配
- 最优适配
- 最差适配

### 2.1 首次适配

按照地址寻找到第一块能够满足需要的空闲块。

![](https://github.com/existorlive/existorlivepic/raw/master/%E6%88%AA%E5%B1%8F2020-10-14%20%E4%B8%8B%E5%8D%885.33.42.png)

**原理及实现**

- 空闲分区列表按照地址排序
- 分配过程中，搜索一个合适的分区
- 释放分区时，检查是否可以和临近的空闲分区合并

**优点**
- 简单
- 在高地址空间有大块的空闲分区

**缺点**
- 产生外部碎片
- 分配大块时较慢

### 2.2 最优适配

避免分割较大的分区

减小碎片的尺寸

![](https://github.com/existorlive/existorlivepic/raw/master/%E6%88%AA%E5%B1%8F2020-10-14%20%E4%B8%8B%E5%8D%885.38.58.png)

**原理及实现**

- 空闲分区列表按照尺寸升序排序
- 分配过程中，搜索一个合适的分区
- 释放分区时，检查是否可以和临近的空闲分区合并

**优点**
- 简单
- 在大部分分配是小尺寸时非常有效
   
   - 减小碎片的尺寸 
   - 避免大的分区被拆分

**缺点**
- 产生外部碎片
- 释放分区重分配慢
- 易产生很多无用的小碎片

### 2.3 最差适配

避免产生太多的较小碎片

![](https://github.com/existorlive/existorlivepic/raw/master/%E6%88%AA%E5%B1%8F2020-10-14%20%E4%B8%8B%E5%8D%885.43.59.png)


**原理及实现**

- 空闲分区列表按照尺寸降序排序
- 分配过程中，搜索一个合适的分区
- 释放分区时，检查是否可以和临近的空闲分区合并

**优点**
- 避免出现太多较小的碎片
- 在大部分分配是中等尺寸时非常有效

**缺点**
- 产生外部碎片
- 释放分区重分配慢
- 容易破坏大的空闲分区，后续难以分配大的分区


## 3. 内存分区整理

通过调整进程占用的分区位置来减少或避免分区碎片。

### 3.1 压缩式碎片整理

通过移动分配给进程的内存分区，以合并外部碎片。

![](https://github.com/existorlive/existorlivepic/raw/master/%E6%88%AA%E5%B1%8F2020-10-14%20%E4%B8%8B%E5%8D%886.04.07.png)


**问题**：

- 内存整理的时机
- 内存整理的开销（将一段内存拷贝到另一个位置）

### 3.2 交换式碎片整理

当执行某个进程需要更多的内存空间，可以抢占某个等待的进程，将该进程换到外存，回收该进程的地址空间。



![](https://github.com/existorlive/existorlivepic/raw/master/%E6%88%AA%E5%B1%8F2020-10-14%20%E4%B8%8B%E5%8D%886.10.31.png)

![](https://github.com/existorlive/existorlivepic/raw/master/%E6%88%AA%E5%B1%8F2020-10-14%20%E4%B8%8B%E5%8D%886.11.01.png)

![](https://github.com/existorlive/existorlivepic/raw/master/%E6%88%AA%E5%B1%8F2020-10-14%20%E4%B8%8B%E5%8D%886.11.10.png)














