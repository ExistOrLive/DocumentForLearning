# 非连续内存分配之分页

## 1. 页表的结构

每一个进程都有一个页表：

- 每个页面对应一个页表项，key是页号，value是页表项
- 随进程运行状态而动态变化
- 页表基址寄存器 

页表项由帧号和三个标志位组成： 

- 帧号 f
- 页表项标志位：
    
     - 修改位(dirty bit)
     - 存在位(resident bit) 
           
            存在位 = 0 ，代表页没有对应的帧
     - 引用位(clock/reference bit)

![](https://github.com/existorlive/existorlivepic/raw/master/%E6%88%AA%E5%B1%8F2020-10-16%20%E4%B8%8B%E5%8D%885.41.10.png)


## 2. 页式存储管理机制的性能问题

### 2.1 内存访问耗时的问题

访问一个内存单元需要访问两次内存：先访问页表项，再访问数据

通过CPU**缓存**一部分最近的常见页表项，减少耗时


### 2.2 页表的保存的空间消耗

页表会非常大

每一个页号都对应一个页表项。如果在64位的系统中，每个帧大小为1024字节，则将有$2^{54}$个页表项，这是极大的内存消耗。

采用多级页表方式和反向页表方式**间接访问**，减少内存消耗。


## 3. 快表TLB

**TLB(Traslation Look-asider Buffer)** 在CPU中缓存近期访问的页表项

- TLB可以快速的访问
- 如果TLB命中页号，可以快速获取帧号
- 如果TLB未命中，则更新表项到TLB

![](https://github.com/existorlive/existorlivepic/raw/master/%E6%88%AA%E5%B1%8F2020-10-16%20%E4%B8%8B%E5%8D%885.59.33.png)

快表TLB减少访问内存的时间消耗。

## 4. 多级页表

将页号分成多级，页表也分成多级；

对于没有帧对应的页，就可以不生成对应的子页表，减少存储的消耗。

(一级页表保存在一个连续的存储空间，每个页号对应一个页表项。即使其中部分页号没有对应的帧，我们也无法减少这些无用页号的页表项。 当采用多级页表，则可以对没有帧对应的子页表进行省略)

![](https://github.com/existorlive/existorlivepic/raw/master/%E6%88%AA%E5%B1%8F2020-10-16%20%E4%B8%8B%E5%8D%885.59.33.png)


## 5. 页寄存器和反置页表

在计算机中，逻辑页的数量与地址寄存器位数有关，物理帧的数量与物理内存大小有关。逻辑地址空间增长速度快于物理地址空间。

### 5.1 大地址空间问题

在逻辑地址空间很大的情况下，页表存储的开销很大；如果采用多级页表方式，内存访问又会变得很繁琐和耗时。

**正常的页表以页号为索引，页表项为逻辑页的数量；如果以帧号为索引，那么页表项就会减少很多内存消耗。**

### 5.2 页寄存器

![](https://github.com/existorlive/existorlivepic/raw/master/%E6%88%AA%E5%B1%8F2020-10-16%20%E4%B8%8B%E5%8D%886.36.00.png)

**优点**
- 页表大小相对于物理内存来说很小
- 页表大小和逻辑地址空间无关

**缺点**
- 需要遍历页表，根据帧号查找页号


### 5.3 基于关联内存 

将反向的页表保存在像TLB一样的关联内存中，但是实现成本太高

### 5.4 反置页表

基于Hash映射查找对应页表项：
    
    以页号和进程号为hash算法的输入，
    输出为对应页表项的索引。

![](https://github.com/existorlive/existorlivepic/raw/master/%E6%88%AA%E5%B1%8F2020-10-16%20%E4%B8%8B%E5%8D%886.50.02.png)












