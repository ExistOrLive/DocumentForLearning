# 局部页面置换算法

## 1. 最优页面置换算法

**基本思路**：在发生缺页中断时，计算内存中每个逻辑页面下一次的使用时间，找出距离下次使用时间最长的页面，作为被置换的页面

实际系统中无法实现，因此系统无法预知页面下次访问的时间。

但是可以作为置换算法的性能评价依据。

## 2. 先入先出页面置换算法

**基本思路**：在内存中找出驻留内存时间最长的页

**实现**：
   
   - 维护一个记录所有位于内存中的逻辑页面链表
   - 链表元素按驻留内存的时间排序，链首最长，链尾最短
   - 出现缺页时，选择链首页面进行置换，新页面加到链尾

**特征**

   - 实现简单
   - 性能差，调出页面可能是经常访问的
   - 进程分配物理页面数增加时，缺页并不一定减少(Belady现象)
   - 很少单独使用

## 3. 最近最久未使用算法(least recently used,LRU)

**基本思路**： 在内存中选择一个最久未使用的页面置换

### 3.1 LRU的实现

开销比较大

**链表实现**

链表头部是最近使用的页面，尾部是最近未使用的页面。

每次访问内存都需要更新链表，更新链表需要查找整个链表


**栈实现**

栈顶是最近访问页面。

每次访问内存都需要更新栈，更新栈 需要查找整个栈。 

## 4. 时钟页面置换算法

Clock页面置换算法：LRU的近似，对FIFO的时间

**基本思路**：

- 需要使用页表项中的访问位。当一个页面装入内存，把该位初始化位0；如果页面被访问，该位初始化位1。

- 把页面组织为环形链表，将指针指向最先进入的页面

- 当发生缺页中断时，考察指针指向的页面，若它的访问位为0，则立即置换；若访问位为1，则访问位置0，然后指针指向下一格。如此找下去，直到找到被置换的页面，然后把指针移动到下一格。


**对于访问位的修改由硬件执行。** 

![](https://pic.existorlive.cn/%E6%88%AA%E5%B1%8F2020-10-18%20%E4%B8%8B%E5%8D%888.35.04.png)

![](https://pic.existorlive.cn/%E6%88%AA%E5%B1%8F2020-10-18%20%E4%B8%8B%E5%8D%888.43.48.png)

## 5. 二次机会法(强化时钟置换法)

修改过的“脏页”(dirty bit 置 1)被置换的代价较高，需要将该页写入到硬盘。 

修改Clock算法： **允许脏页在一次时钟扫描中保留下来**。

**二次机会法步骤** 

时钟中断发生时，检查当前指针指向的页：
     
- 如果该页的dirty bit和access bit都为0，则直接置换；
- 如果该页的dirty bit和access bit都为1，则access bit置为0；指针指向下一个指针
- 如果该页的dirty bit和access bit 有一个为1，则置为0；指针指向下一个指针

## 6. 最不常用算法(Least Frequently Used,LFU)

**基本思路**： 缺页时，置换访问次数最少的页面

**实现**：

- 每个页面设置一个访问计数
- 访问页面时，访问计数加1
- 缺页时，置换访问次数最少的页面

**特征：**

- 算法开销大

- 开始时频繁使用，但以后不使用的页面很难置换
     
      计数定期右移

**LRU和LFU的区别：**

- LRU关注多久未访问，时间越短越好
- LFU关注访问次数，次数越多越好


## 7. belady现象

在FIFO算法中，有时分配的物理页面增加，缺页率反而提高的现象。

- FIFO算法的置换特征与进程访问内存的动态特征矛盾

- 被它置换出去的页面并不一定是进程近期不会访问的

## 8. FIFO，LRU和Clock的比较

1. FIFO，LRU本质上都是先进先出的思路。

    - LRU依据页面的最近访问时间排序，会动态调整
    - FIFO依据页面进入内存的时间排序，固定不变
    - LRU可退化成FIFO，如页面进入内存后没有被访问，最近访问时间与进入内存的时间相同

2. LRU算法性能较好，但系统开销较大；FIFO算法系统开销较小，会发生Belady现象；Clock算法是它们的折衷








     



