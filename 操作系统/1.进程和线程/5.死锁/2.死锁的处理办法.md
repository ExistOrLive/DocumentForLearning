# 死锁的处理办法

- 死锁预防

- 死锁避免

      进程在请求资源前，检查是否会发生死锁；只允许不会发生死锁的进程请求资源

- 死锁检测

      在检测到操作系统进入死锁状态，进行修复

- 死锁修复

## 1. 鸵鸟策略

检测和恢复死锁的开销较大，操作系统通常忽略死锁，由应用程序去处理死锁。

## 2. 死锁预防

破坏死锁发生的4个必要条件：

- 破坏互斥条件 ： 
    
       资源共享不再互斥/不占用共享资源

- 破坏占用并等待 ： 进程执行前就申请所有的资源

       需要在运行前就知晓需要的资源；
         资源利用率低

- 无抢占：

       如果进程请求的资源不能立刻分配，就释放已经占有的资源；
       只有在能获取所有需要的资源时，才分配资源


- 破坏循环等待：

         对所有的资源进行排序，并要求每个进程按照资源的顺序进行申请（使用资源类型有限的嵌入式系统）


## 3. 死锁避免

利用**额外的先验信息**，在分配资源时判断是否会出现死锁，只有在不会出现死锁的时候分配资源。

- 进程需要声明需要**资源的最大数目**

- 限定提供和分配资源的数量，确保满足进程的最大需求

- 动态检查的资源分配状态，确保不会出现死锁

### 3.1 安全状态 

如果系统中没有发生死锁，并且即使所有的进程突然请求对资源的最大需求，也仍然**存在某种调度次序**能够使每一个进程都执行结束，则称为**安全状态**。

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2020-10-10%20%E4%B8%8A%E5%8D%882.29.58.png)

系统在安全状态不会出现死锁，在不安全状态可能出现死锁，因此避免死锁就是避免进入非安全状态。


### 3.2 银行家算法 

银行家算法是一个避免死锁产生的算法。以银行借贷分配策略为基础，判断并保证系统处于安全状态。

银行相当于操作系统；
银行的资金相当于系统中的资源；
银行的用户相当于进程。


- 进程在创建时，需要声明需要的最大资源数

- 进程需要的资源数，不得超过系统拥有的最大资源数

### 3.3 银行家算法数学模型

n = 线程数量, m = 资源类型数量

- Max（总需求量）: n×m矩阵
     
      线程Ti最多请求类型Rj的资源 Max[i,j] 个实例

- Available（剩余空闲量）：长度为m的向量
          
      当前有 Available[j] 个类型Rj的资源实例可用

- Allocation（已分配量）：n×m矩阵
     
      线程Ti 当前分配了 Allocation[i, j] 个Rj的实例

- Need（未来需要量）：n×m矩阵

      线程Ti 未来需要 Need[i, j] 个Rj资源实例


$$
Need[i,j] = Max[i,j] – Allocation[i,j]
$$


**3.3.1 判断是否为安全状态**

1. `Work` 和 `Finish` 分别是长度为m和n的向量初始化:

       Work = Available              //当前可用的资源
       Finish[i] = false for i：1,2, …, n. //每个线程的状态(是否结束)

2. 寻找满足条件的线程
       
       满足以下条件：
       Need[i] <= Work
       Finish[i] == false 

       找到转到步骤3；没有找到转到步骤4

3. 将满足条件的线程结束,回收资源

        Work = Work + Allocation[i]
        Finish[i] = true

        如果还有线程没有结束，回到步骤2

4. 如果所有的线程都结束，则系统处于安全状态；否则处于非安全状态。


**3.3.2 某个进程申请资源，使用银行家算法判断是否会出现死锁**

1. 初始化: Requesti 线程Ti的资源请求向量; Requesti[j] 线程Ti请求资源Rj的实例

2. 如果 Requesti ≤ Need[i], 转到步骤2。否则, 拒绝资源申请, 因为线程已经超过了其最大要求

3. 如果 Requesti ≤ Available, 转到步骤3。否则, Ti 必须等待, 因为资源不可用

4. 通过安全状态判断来确定是否分配资源给Ti : 
   

## 4. 死锁检测

- 不同于死锁避免，系统允许进入死锁状态

- 维护系统当前的系统分配图

- 定期调用死锁检测算法来搜索图中存在死锁

- 出现死锁时，使用死锁恢复机制进行恢复

死锁检测算法开销不小，以什么样的机制何时去运行死锁检测算法是一个问题。


## 5. 死锁恢复 

### 5.1 终止进程

- 终止所有的死锁进程

- 一次只终止一个进程直到死锁消除

- 终止进程的顺序应该是
  
     - 进程的优先级

     - 进程已运行时间以及还需运行时间

     - 进程已占用资源

     - 进程完成需要的资源

     - 终止进程数目

     - 进程是交互还是批处理


### 5.2 资源抢占

- 选择被抢占的进程
    
       最小成本目标

- 进程回滚

      回滚至安全状态

- 可能出现饥饿

      同一个进程可能一直被选为被抢占的进程


