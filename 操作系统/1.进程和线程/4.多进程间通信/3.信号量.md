# 信号量

**信号量(Semaphore)** 是一个抽象数据结构，由一个整型数sem，和两个原子操作PV组成。

PV操作是单一的，不可分割的原子操作，保证一旦一个信号量开始操作，则在操作完成或者阻塞前，其他进程不可以访问该信号量。

- P(): sem--, 如果sem < 0,当前进程阻塞，否则继续执行

- V(): sem++, 如果sem <=0,唤醒一个等待的进程，唤醒的进程按照先来先服务的机制选取。

## 1. 使用信号量

> 信号量可以用于实现互斥和进程同步。

## 1.1 互斥

```c++
// 创建一个计数为1的信号量
sem = new Semaphore(1);   

...

sem->p();

// critical section

sem->v();

```

## 1.2 实现同步

```c++
// 创建一个计数为0的信号量
sem = new Semaphore(0); 

// 进程1

...
sem->p()
...



// 进程2
...
sem->v()
...

// 进程1 等待 进程2执行完成

```


## 2. 信号量的实现


```c++

class Semaphore{
    int sem;         // 保存信号量的值
    Queue q;         // 保存在信号量上等待进程/线程队列，先入先出

    P(){
        sem --;
        if(sem < 0){
            Thread t = getCurrentThread()
            q.push(t);
            t.sleep();
        }
    }

    V(){
        sem ++;
        if(sem <=0){
            Thead t = q.pop();
            t.wakeup();          // 从队尾去除线程并唤醒
        }
    }
}

```



## Tip

> 信号量是保存在内核中整型数，可以被多个进程共享。










