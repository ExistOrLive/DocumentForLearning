# 概述

多进程间通信主要关注三个问题：

1. 一个进程如何把信息传递给另一个 (共享内存，管程)

2. 进程访问同一个资源 (读写一块内存如何保证进程安全)

3. 进程间如何同步 (一个进程需要等待另一个进程的结果)

## 竞争条件(race condition)

两个或者多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，称为**竞争条件**。

```c
// 多进程(线程)共享 next_pid ， 每个进程读取next_pid的值到new_pid，再对next_pid++

int next_pid = 100;

//...
int new_pid = next_pid ++;
//...
```
翻译为汇编

```
# 翻译为4句汇编指令，每个指令才是一个原子操作。
LOAD next_pid Reg1
STORE Reg1 new_pid
INC Reg1
STORE Reg1 next_pid
```

CPU可以在进程执行到任何一句会汇编指令时，切换进程。

![](https://pic.existorlive.cn/%E6%88%AA%E5%B1%8F2020-10-05%20%E4%B8%8B%E5%8D%888.08.48.png)

在上图的执行过程中，进程1获取的new_pid和进程2获取的new_pid是一样的；这与顺序执行进程1和进程2的结果是不一致。**运行的结果与进程执行的精确时序有关。**


我们期望在多进程运行的情况下，运行的结果应该是与多个进程运行的时序无关，结果是确定的。

## 原子操作(atomic operation)

**原子操作**是一次不存在任何中断或者失败的执行。

- 原子操作
    
      一次机器指令的执行

- 非原子操作

      x++ 并不是原子操作，由三条指令组成


## 临界区(critical section)

**临界区** 进程中需要访问共享资源的代码，并且当一个进程处于这块代码区域另一个进程就无法在这块代码执行

- 任何两个进程不能同时处于临界区

- 不得是进程无限期等待进入临界区

- 不应对CPU的速度和数量做假设

- 临界区外的进程不得阻塞其他进程

## 互斥(mutual exclusion)

**互斥** 当一个进程处于临界区访问共享资源时，没有其他的进程会处于临界区。

## 死锁(Dead lock)

**死锁** 两个或者以上的进程，在相互等待完成特定任务，而最终没法将自身任务进行下去。

## 饥饿(starvation)

一个可执行的进程，被调度器持续忽略，以至于虽然处于可执行状态却一直不被执行。


>  任何可能会发生的问题终将会发生。







