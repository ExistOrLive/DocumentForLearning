# 调度算法

## 1. 先来先服务(FCFS)

按照进程进入就绪队列的顺序排队；当前进程进入等待或者结束状态，就绪队列下一个进程占用CPU

### 优点：

简单

### 缺点：

- 平均等待时间波动大
  
       短进程靠前，平均等待时间较低；
       但是短进程可能排在长进程后面

- I/O资源和CPU利用率低

       CPU密集型进程占用CPU会导致I/O设备闲置，I/O密集型进程也等待


## 2. 短进程优先(SPN)

选择就绪队列中执行时间最短的进程占用CPU

- 不可抢占

- 可抢占

      短剩余时间优先(SRT)
   
      如果新插入就绪队列的进程预期运行时间比当前进程剩余执行时间短，抢占CPU

### 优点：

最优平均周转时间

     短进程优先执行，等待时间短

### 缺点：

- 可能导致长进程饥饿

- 需要预知进程的执行时间

     - 询问用户
     - 使用历史执行时间预估未来的执行时间


## 3. 高响应比算法

选择就绪队列中响应比R最高的进程：

$
R = ( W + S ) / S; W等待时间，S执行时间
$

可以处理进程饥饿的情况


## 4. 时间片轮转算法(RR)

时间片：分配CPU资源的基本时间单元

![](https://github.com/existorlive/existorlivepic/raw/master/%E6%88%AA%E5%B1%8F2020-09-29%20%E4%B8%8B%E5%8D%884.46.27.png)

当前进程时间片结束后，按FCFS算法切换到下一个进程执行

- RR算法开销：
    
        额外的上下文切换

- 时间片太大
  
       等待时间过长； 
       极限情况退化为FCFS

- 时间片太小

       反应迅速，但是产生大量上下文切换开销

       影响吞吐量

- 选择合适的时间片

       维持上下文切换开销在1%

## 5. 多级反馈队列算法(MQ)

就绪队列分成多个独立的子队列：

       例如分成前台队列（响应速度快） 后台队列（吞吐量大）

每个队列拥有自己的调度策略：

        前台队列（RR） 后台队列(FCFS)

队列间的调度：
  
- 固定优先级
      
       先处理前台，后处理后台；可能会导致饥饿

- 时间片轮转
    
        每个队列都得到一个确定的能够调度其进程的CPU时间

- 多级反馈队列

      进程在不同优先级队列间移动；
      时间片随着优先级的降低而增加；
      进程在当前时间片内没有完成，则下降一个优先级

      CPU密集型进程优先级下降很快；
      IO密集型进程停留在高优先级

  ![](https://github.com/existorlive/existorlivepic/raw/master/%E6%88%AA%E5%B1%8F2020-09-29%20%E4%B8%8B%E5%8D%885.05.26.png)




## 6. 公平共享调度算法（FSS）

控制用户对系统的访问：

- 一些用户组比其他用户组更重要
- 保证不重要的用户组无法垄断资源

## 总结

- FCFS
  
      不公平，平均等待时间变动很大

- 短进程优先

      平均周转时间最小
      需要预测执行时间
      可能会导致饥饿

- 高响应比优先

       基于短进程优先改进，避免饥饿

       不可抢占

- 时间片轮转

       比较公平

       响应速度快

       平均等待时间较差

- 多级反馈队列

       多种算法集成

- 公平共享算法

        公平是第一要素·