# 管理文件系统的数据结构

**卷控制块** (Unix: “superblock”)

- 每个文件系统一个
- 文件系统详细信息
- 块、块大小、空余块、计数/指针等

**文件控制块** (Unix: “vnode” or “inode”)

- 每个文件一个
- 文件详细信息
- 访问权限、拥有者、大小、数据块位置等

**目录项** (Linux: “dentry”)

- 每个目录项一个(目录和文件)
- 将目录项数据结构及树型布局编码成树型数据结构
- 指向文件控制块、父目录、子目录等

**这些数据结构保存在二级存储中，在需要时加载进内存**

- 卷控制模块 : 当文件系统挂载时进入内存
- 文件控制块: 当文件被访问时进入每次
- 目录节点: 在遍历一个文件路径时进入内存

![](https://github.com/existorlive/existorlivepic/raw/master/%E6%88%AA%E5%B1%8F2020-10-26%20%E4%B8%8B%E5%8D%887.39.13.png)


# 打开文件的数据结构

打开文件就是将文件控制块读入内存，并在系统和进程的打开文件表中建立表项，返回文件描述符。

操作系统维护了三级的打开文件表：

- 每个进程都有一个打开文件表
- 系统级的打开文件表
- 文件系统的i-node表

![](https://github.com/existorlive/existorlivepic/raw/master/%E6%88%AA%E5%B1%8F2020-10-27%20%E4%B8%8B%E5%8D%888.12.55.png)

1. 由于进程级文件描述符表的存在，不同的进程中会出现相同的文件描述符，它们可能指向同一个文件，也可能指向不同的文件
    
2. 两个不同的文件描述符，若指向同一个打开文件句柄，将共享同一文件偏移量。因此，如果通过其中一个文件描述符来修改文件偏移量（由调用read()、write()或lseek()所致），那么从另一个描述符中也会观察到变化，无论这两个文件描述符是否属于不同进程，还是同一个进程，情况都是如此。
    
3. 要获取和修改打开的文件标志（例如：O_APPEND、O_NONBLOCK和O_ASYNC），可执行fcntl()的F_GETFL和F_SETFL操作，其对作用域的约束与上一条颇为类似。
    
4. 文件描述符标志（即，close-on-exec）为进程和文件描述符所私有。对这一标志的修改将不会影响同一进程或不同进程中的其他文件描述符

