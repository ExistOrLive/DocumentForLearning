let a:[number, number?] = [1];

console.log(tuple[0])      // 1

console.log(tuple[1])      // undefined 

console.log(tuple[2])      // 报错 
 
```

使用扩展运算符可以创建成员数量不限的元组。

```ts 
type NamedNums = [
  string,
  ...number[]
];

const a:NamedNums = ['A', 1, 2];
const b:NamedNums = ['B', 1, 2, 3];

type t1 = [string, number, ...boolean[]];
type t2 = [string, ...boolean[], number];
type t3 = [...boolean[], string, number];

```

### 2.  只读元组

```ts 
// 写法一
type t = readonly [number, string]

// 写法二
type t = Readonly<[number, string]>
```

### 3. 元组成员数量的推断

如果没有可选成员和扩展运算符，TypeScript 会推断出元组的成员数量（即元组长度）。

当访问不存在的成员，将会报错。

```ts 
let tuple: [string,string?] = ["Hello", "World"]

console.log(tuple[1])

console.log(tuple[2]).      // 报错 
```

![](https://pic.existorlive.cn//202402181156843.png)

当时使用可选成员，元组成员数量不确定，但是有最大数量，当访问超出长度的成员，将会报错。

```ts

let tuple: [string,string?] = ["Hello"]

console.log(tuple[1]).     // undefined

console.log(tuple[2])      // 报错
```

![](https://pic.existorlive.cn//202402181157521.png)

当使用扩展运算符时，元组成员最大数量也不确定

```ts

let tuple: [string,...number[]] = ["Hello", 1 ]

console.log(tuple[1])         // 1

console.log(tuple[2])         // undefined

```