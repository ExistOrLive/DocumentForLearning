# dyld

当内核完成映射进程的工作后，会将名字为 dyld 的 Mach-O 文件映射到进程中的随机地址，它将PC 寄存器设为 dyld 的地址并运行。dyld 在应用进程中运行的工作是加载应用依赖的所有动态链接库，准备好运行所需的一切，它拥有的权限跟应用程序一样。

`dyld（the dynamic link editor），【动态链接器】`是苹果操作系统一个重要部分，在 iOS / macOS 系统中，仅有很少的进程只需内核就可以完成加载，基本上所有的进程都是动态链接的，所以 Mach-O 镜像文件中会有很多对外部的库和符号的引用，但是这些引用并不能直接用，在启动时还必须要通过这些引用进行内容填充，这个填充的工作就是由 dyld 来完成的。

【动态链接加载器】在系统中以一个用户态的可执行文件形式存在，一般应用程序会在Mach-O文件部分指定一个 `LC_LOAD_DYLINKER` 的加载命令，此加载命令指定了dyld的路径，通常它的默认值是`“/usr/lib/dyld”`。系统内核在加载Mach-O文件时，会使用该路径指定的程序作为动态库的加载器来加载dylib。



## dyld2
共享缓存

dyld加载时，为了优化程序启动，启用了共享缓存（shared cache）技术。共享缓存会在进程启动时被dyld映射到内存中，之后，当任何Mach-O镜像加载时，dyld首先会检查该Mach-O镜像与所需的动态库是否在共享缓存中，如果存在，则直接将它在共享内存中的内存地址映射到进程的内存地址空间。在程序依赖的系统动态库很多的情况下，这种做法对程序启动性能是有明显提升的。


## dyld3

![](http://pic.existorlive.cn/%E6%88%AA%E5%B1%8F2022-10-10%20%E4%B8%8B%E5%8D%881.54.23.png)

在 iOS 13之前，所有的第三方App都是通过dyld 2来启动 App 的，主要过程如下：

- 解析 Mach-O的Header 和 Load Commands，找到其依赖的库，并递归找到所有依赖的库
- 加载Mach-O文件
- 进行符号查找
- 绑定和变基
- 运行初始化程序

dyld 3被分为了三个组件：

- 一个进程外的Mach-O 解析器
预先处理了所有可能影响启动速度的search path、@rpaths 和环境变量
然后分析Mach-O的Header和依赖，并完成了所有符号查找的工作
最后将这些结果创建成一个启动闭包
这是一个普通的daemon进程，可以使用通常的测试架构

- 一个进程内的引擎，用来运行启动闭包
这部分在进程中处理
验证启动闭包的安全性，然后映射到dylib之中，再跳转到main函数
不需要解析Mach-O的 Header 和依赖，也不需要符号查找。

- 一个启动闭包缓存服务
系统App的启动闭包被构建在一个Shared Cache 中，我们甚至不需要打开一个单独的文件
对于第三方的App，我们会在App安装或者升级的时候构建这个启动闭包。
在iOS、tvOS、watchOS中，这一切都是App启动之前完成的。在macOS上，由于有Side Load App，进程内引擎会在首次启动的时候启动一个daemon进程，之后就可以使用启动闭包启动了。


dyld 3 把很多耗时的查找、计算和I/O 的事件都预先处理好，这使得启动速度有了很大的提升。


[iOS 应用程序加载](https://juejin.cn/post/6882647026188222471#heading-18)
