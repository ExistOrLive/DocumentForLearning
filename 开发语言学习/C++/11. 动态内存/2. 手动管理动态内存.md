# 1. 手动管理动态内存

C++使用`new`和`delete`运算符来管理动态内存。

`new`: 在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象初始化

`delete`：接受一个动态对象的指针，销毁该对象，并释放内存

## 1. 使用new创建动态对象并初始化

```c++
int *p1 = new int;         // 默认初始化，值是未定义的
int *p2 = new int();       // 值初始化，0
int *p3 = new int(15);

string *p4 = new string;     // 默认初始化
string *p5 = new string();   // 值初始化
string *p6 = new string(5,'a');
string *p7 = new string("Hello World");

```

默认情况下，动态分配的对象是默认初始化。内置类型或组合类型的对象的值将是未定义的，类类型对象将用默认构造函数进行初始化。

在内置类型后加上括号可以值初始化，初值为0，false或者nullptr

类类型对象无论怎么初始化，最后都会调用到构造函数。

### 1.1 动态分配const对象

```c++
// 分配并初始化const int
const int *p = new const int(1024);

// 
const string *strp = new const string();

```
一个动态分配的const对象必须初始化，返回一个指向const的指针。


## 2. 使用delete释放动态内存

`delete`销毁给定的指针指向的对象，释放对应的内存。

> 手动管理的动态内存在被显式释放前一直都会存在

```c++
int i, *pil = &i, *pil2 = nullptr;
double *pd = new double(33), *pd2 = pd;

delete i;               // 报错， i 不是指针
delete pil;             // 未定义， pil 不是指向动态内存
delete pil2;            // 通过，pil2是空指针

delete pd;              // 通过，释放pd指向的内存
delete pd2;             // 未定义的，多次释放同一块内存 


```

### `delete`使用的注意项

1. delete只能销毁动态内存，不能接受指向栈内存的指针。

2. 将相同的指针delete多次，其结果是未定义的

3. 动态内存被delete之后，指向该内存的指针属于野指针，不可以再使用，最好置为nulptr



## 3. 内存耗尽

默认情况下，如果`new`不能分配所要求的内存，它会抛出一个类型为`bad_alloc`的异常。

可以通过`nothrow`阻止异常的抛出

```c++

int *p = new (nothrow) int(10);       // 如果分配失败返回一个空指针

```

## 4. 手动管理动态内存的弊端

手动管理的动态内存在被显式释放前一直都会存在，一直不释放就会造成内存泄漏。但是如何确定一块动态内存何时不再被使用，是个很困难的问题。如果在一个时间点释放掉某块动态内存，但是在这之后又使用了这块内存，结果将是未定义的。

特别是在多线程的情况下，多个线程间共享堆内存。访问已经释放的动态内存，多次delete同一块内存，一直不释放某块内存造成内存泄漏这些问题频繁发生。




