# 动态数组

## 1. 手动管理动态数组

使用`new`创建动态数组

```c++
int *p1 = new int[10];         // 创建长度为10的动态数组，默认初始化

int *p2 = new int[10]();      // 创建长度为10的动态数组，值初始化

int *p3 = new int[10]{1,2,3,4,4,5,6,6};      // 列表初始化，剩余值初始化

int *p4 = new int[0];         // 可以创建长度为0的数组，但是不能解引用

```

使用`delete []`释放动态数组

```c++

delete p;       // p必须指向一个动态分配的对象或者为空

delete []p;     // p必须指向一个动态分配的数组或或者为空

```

> 如果我们在delete一个数组指针时忘记方括号，或者在delete一个单一对象的指针时使用方括号，编译器很可能不会给出警告，但结果是未定义的。

## 2. 使用智能指针管理动态数组

`unique_ptr`可以直接管理动态数组

```c++
// 初始化一个指向动态数组的智能指针
unique_ptr<int[]> p(new int[10]());

p[0];             // 访问动态数组

p.release();      // 自动调用delete[] 销毁指针

```

`shared_ptr`不能直接管理动态数组，只能定义一个指向单独对象的智能指针，同时传入一个自定义删除器

```c++
// 只能定义一个指向单独对象的智能指针，同时传入一个自定义删除器
shared_ptr<int> sp(new int[10](),[](int *p){
    delete []p;
});
```

`shared_ptr`无法直接访问动态数组中的元素，需要获取到普通指针，再访问。

```c++
for(size_t i = 0; i != 100; ++i){
    *(sp.get() + i) = i;   // 获取普通指针，再访问。
}
```



