# 构造函数和拷贝控制和继承

## 1. 虚析构函数

**基类的析构函数应该是虚函数**

当一个基类指针指向派生类对象，对象销毁时，会调用析构函数。如果析构函数不是虚函数，则只会调用基类的析构函数。

**虚析构函数将阻止合成移动操作**


## 2. 合成拷贝控制和继承

### 2.1 基类和派生类的合成的拷贝控制成员

在定义类时，如果未显式定义默认构造函数，拷贝构造，移动构造，拷贝赋值运算符和移动赋值运算符时，一般编译器会合成对应的默认函数。

当派生子类时，如果未显式定义默认构造函数，拷贝构造，移动构造，拷贝赋值运算符和移动赋值运算符时，也会为其合成对应的成员。

**子类的合成成员除了会对类本身的成员依次进行初始化，赋值或销毁操作，还会调用父类对应的操作对父类的成员依次进行初始化，赋值或销毁操作。**

### 2.2 基类和派生类的删除的合成的拷贝控制成员

在定义类时，在某些条件下，拷贝控制成员可能是删除的。如类的某个成员没有实现拷贝构造，那么该类的合成拷贝构造是删除的。

如果基类的拷贝控制成员是删除的或者派生类无法访问，派生类的对应的合成拷贝控制成员也是删除的。


### 2.3 派生类显式定义拷贝控制成员

除了析构函数，派生类在定义拷贝控制成员时，都需要显式调用父类对应的拷贝控制成员。

如果基类的拷贝构造，移动构造，拷贝赋值运算符，移动赋值运算符是删除的或者派生类无法访问，子类也无法定义对应的成员。

```c++
class SuperClass{

int a;

 /**
  * 显示定义了构造函数，默认构造函数是删除的
  * 显示定义了拷贝构造函数
  * 合成了默认拷贝赋值运算符
  * 合成的移动构造函数和移动赋值运算符是删除的
  */

SuperClass(int a){   
    this->a = a;
}

SuperClass(const SuperClass& obj) = default;

virtual ～SuperClass() = default;

};



class SubClass : public SuperClass{

int b;

// 父类没有默认构造函数，子类必须显示调用其他构造函数
SubClass():SuperClass(11),b(11){

}

SubClass(const SubClass& obj):SuperClass(obj),b(obj.b){
}

SubClass& operator=(const SubClass& obj){
    SuperClass::operator=(obj);    // 显式调用父类的拷贝赋值运算符
    b = obj.b;
}

SubClass& operator=(SubClass&& obj){
    SuperClass::operator=(obj);    // 报错，父类的移动赋值运算符是删除的
    b = obj.b;
}

};

```


## 3. 在构造函数和析构函数中调用虚函数

**在构造函数和析构函数中调用虚函数，是不会发生动态绑定的**。

在执行构造函数和析构函数的代码时，我们认为对象还没有完全初始化完毕，处于一个非安全状态，不会发生动态绑定。

如果一个子类对象销毁，父类的析构函数中调用的虚函数能够发生动态绑定。此时子类部分的资源已经销毁，调用虚函数发生动态绑定，访问子类的资源，其结果是未定义的。



## 4. 继承的构造函数

**在C++11新标准中，派生类能够重用其直接基类定义的构造函数。**

类不能继承默认，拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。

子类通过`using`关键字重用直接父类的构造函数

```c++
class SuperClass{

int a;
int b;

public:

SuperClass(int a,int b):a(a),b(b){}

virtual ～SuperClass() = default;

};

class SubClass{

public:

using SuperClass::SuperClass;  // 重用父类的构造函数
}

```

`using`声明语句只是令某个名字在当前作用域内可见。而当作用于构造函数，`using`声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。

如果派生类含有自己的数据成员，则这些成员将会默认初始化。

## 4.1 继承的构造函数特点

- 继承的构造函数，访问级别也会继承

- 父类的构造函数是constexpr或explicit，继承的构造函数也是constexpr或explicit的

- 父类的构造函数含有默认实参，继承的构造函数将是多个重载构造函数。

- 默认，拷贝和移动构造函数不会继承，而是为子类合成













