# 继承中的类型转换

**父类的引用和指针可以绑定公有继承的子类的对象,私有继承和保护继承则不可以**

私有继承和保护继承的子类对象，在使用该对象时是无法访问父类的成员的。

```c++
Quote a;

Bluk_quote b;

Quote &quote1 = a;

Quote &quote1 = b;
 
```

## 1. 动态绑定与类型转换

父类的引用和指针可以绑定公有继承的子类的对象。那么我们在使用父类的引用和指针时，就难以确定具体的对象什么类型。

- **在父类的引用和指针调用虚函数，会发生动态绑定，调用具体实现由运行时类型决定**

- **在父类的引用和指针调用非虚函数，和访问数据成员，在编译阶段就确定下来**。

----

## 2. 不存在从父类向子类的隐式类型转换

父类的引用和指针可以绑定子类的对象，但是子类的引用或者指针不能直接绑定父类的对象，即便对实际上是一个子类对象。

```c++

Quote &quote1 = Quote();

Quote &quote2 = Bluk_quote();

Bluk_quote &quote3 = quote2;   // 报错，父类不能够隐式向子类转换

```
### 2.1 将父类引用或指针强制类型转换为子类引用或指针

我们可以通过`dynamic_cast`和`static_cast`强制将父类引用或指针转换为子类引用或指针。

`dynamic_cast`会在运行时检查转换是否去正确，如果不正确，会报错`bad_cast`

`static_cast`不会在运行时检查，因此需要程序员去确保转换正确，否则在使用时结果是未定义的。


```c++

// static_cast 
Bluk_quote &quote3 = static_cast<Bluk_quote&>quote2;      

// dynamic_cast 
Bluk_quote &quote3 = dynamic_cast<Bluk_quote&>quote2;      

// quote1 实际上是Quote对象，但是static_cast不会报错，使用时结果是未定义的
Bluk_quote &quote3 = static_cast<Bluk_quote&>quote1;
// 甚至可以访问子类的成员，但是仅是在编译器根据偏移量确定成员的起始地址，其值是未定义的
quote3.a;  

// quote1 实际上是Quote对象，会在运行时报错bad_cast
Bluk_quote &quote3 = dynamic_cast<Bluk_quote&>quote1;       

```

### 2.2 当子类的引用或指针实际绑定了一个父类的对象

我们可以将父类引用或指针强制类型转换为子类引用或指针。因此，存在这样一种情况，子类的引用或指针实际绑定了一个父类的对象。

- 在调用虚函数时，会发生动态绑定，会调用父类中的函数实现

- 在调用非虚函数时，由于是在编译期确定函数入口地址，调用的是子类中的函数实现

- 在访问数据成员时，即便是父类没有该数据成员，也会根据子类中成员偏移量直接定位，因此访问的结果是未定的。

----

## 3. 父类和子类对象之间不存在类型转换

父类和子类的类型转换发生在指针和引用。

父类和子类的对象之间直接的初始化或者赋值，会调用对应的构造函数和赋值运算符，这样两者就是完全独立的两个对象了。

> 当我们使用一个子类对象为一个父类对象初始化或赋值时，只有该子类对象中父类部分会被拷贝，移动和赋值，它的子类部分将被忽略掉。



----

> 从子类向父类的类型转换只对指针和引用类型有效

> 父类向派生类不存在隐式类型转换

> 派生类向基类的类型转换也可能由于访问受限而变得不可行。