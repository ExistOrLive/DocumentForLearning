# 泛型算法

C++标准库定义了一套算法API，称为**泛型算法**。**泛型算法**只会操作**容器的迭代器**，而不会对容器本身操作。

**泛型算法**运行在容器的迭代器之上，不依赖于容器，但是依赖于元素的操作。
    
      例如排序的泛型算法，操作容器的迭代器，
      与容器本身的类型无关；
      但是排序需要对元素进行比较操作，
      因此排序元素必须要支持比较操作

`algorithm`头文件中定义了2000多种泛型算法。


- 对于只读取而不改变元素的算法，通常最好使用`cbegin()`和`cend()`;需要改变元素的算法，使用`begin()`和`end()`

- 向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳写入的元素

- 标准库算法对迭代器而不是容器操作，因此，算法不能直接添加或删减元素

----

## 1. 泛型算法形参模式

```c++
alg(beg, end, other args);

alg(beg, end, dst, other args);

alg(beg, end, beg2, other args);

alg(beg, end, beg2, end2, other args);

```

- `alg`为算法函数的名字

- `beg`,`end` 两个迭代器表示输入的一个范围

- `dst` 表示输出的一个指定目标位置

- `beg2`,`end2` 表示第二个输入序列的范围

### 1.1 接受单个目标迭代器dst

`dst` 参数表示算法可以写入的目标位置的迭代器。

> 向输出迭代器写入的数据的算法都假定目标空间足够容纳写入的数据。

开发者需要在编程时确保目标迭代器的容量是足够的，不能够出现溢出的情况。

```c++

vector<int> vec(10,11);
forward_list<int> li(5,0);
    
// 将vec的元素拷贝到li，但是li的容量不够;开发者必须确保输出迭代器的容量是够的
copy(vec.cbegin(), vec.cend(), li.begin());

```

一般迭代器无法添加删除容器元素，可以使用插入迭代器`insert_iterator`。`insert_iterator`作为目标输出迭代器，可以不必考虑目标空间的容量。


### 1.2 接受第二个输入序列的算法

`beg`,`end`代表第一个输入序列；`beg1`,`end1`代表第二个输入序列。
这样的算法通常使用两个范围的元素一起进行运算。

> 接受单独的beg2的算法假定从beg2开始的序列与beg和end所表示的范围至少一样大。


---

## 2. 迭代器类别

泛型算法所要求的迭代器操作可以分为5种迭代器类别。每种算法都会对它的每个迭代器参数指明须提供哪种迭代器。

类别|允许的操作
----|----
输入迭代器|只读，不写，单遍扫描，只能递增
输出迭代器|只写，不读，单遍扫描，只能递增
前向迭代器|可读写，多遍扫描，只能递增
双向迭代器|可读写，多遍扫描，能递增递减
随机访问迭代器|可读写，多遍扫描，支持全部迭代器运算

除了输出迭代器之外，一个高层次的迭代器支持低层次的迭代器的所有操作。

### 2.1 输入迭代器

一个输入迭代器必须支持：

- 用于比较两个迭代器的相等和不相等运算符(==,!=)
- 用于推进迭代器的递增运算符(++)
- 用于读取元素的解引用运算符(*,->) ，只能出现在运算符右边。

> 输入迭代器解引用后，只能够作为右值，出现在运算符右边。

> 输入迭代器只能够单遍扫描

因为输入迭代器不能保证扫描后元素的状态还能保存，例如`istream_iterator`无法读取第二遍

```c++

// find算法要求输入迭代器
_InputIterator
find(_InputIterator __first, _InputIterator __last, const _Tp& __value_)

```

### 2.2 输出迭代器

一个输出迭代器必须支持：

- 用于推进迭代器的递增运算符(++)
- 用于元素赋值的解引用运算符(*) ，只能出现在运算符左边。

> 输入迭代器解引用后，只能够作为左值，出现在运算符左边。

> 输出迭代器只能够单遍扫描

```c++

// copy 算法第三个参数就是输出运算符
constexpr OutputIterator copy(InputIterator first, InputIterator last, OutputIterator result);

```

### 2.3 前向迭代器

- 可以读写元素

- 可以多次单向扫描
  
`forward_list`的迭代器就是前向迭代器

```c++

// replace 算法要求迭代器既能读也能写
void
replace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)
```

### 2.4 双向迭代器

- 可以读写元素

- 可以多次双向扫描，支持递减操作(--)

`list`的迭代器就是双向迭代器

### 2.5 随机访问运算符

提供在常量时间内访问序列中任意元素的能力。

- 用于比较两个迭代器相对位置的关系运算符(<,<=,>,>=)
- 迭代器和一个整数值的加减操作(+,+=,-,-=)
- 两个迭代器相减，获取迭代器之间距离
- 下标运算符(iter[n])

除了`forward_list`,`list`,其他容器的迭代器都是随机访问迭代器。

```c++

// sort算法要求随机访问迭代器
void
__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)

```










