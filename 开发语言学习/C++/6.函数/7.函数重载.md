# 函数重载

在**同一个作用域**中，**函数名字相同但是形参列表不同**，称为**函数重载**。

对于重载的函数来说，在形参的数量和类型上有所不同。


## 1. 重载和const形参

一个拥有顶层const的形参无法和没有顶层const的实参区分开来。但是可以区分底层const的实参和非底层const的实参。

**底层const的区分对函数重载有效，而顶层const无效**

```c++
bool find(int a);
bool find(const int a);   // 认为这两个函数重复声明了，不是函数重载

bool find(int &a);
bool find(const int &a);  // 认为是函数重载

```

## 2. 重载与作用域

**我们在内层作用域中声明的名字会掩盖外层作用域中相同的名字。**

在内层作用域中声明的函数会掩盖外层作用域中的同名函数。

**C++语言中，名字的查找发生在类型检查之前。**

一旦在当前作用域中找到所需的名字，编译器就会忽略掉外层作用域中的同名实体，剩下的工作就是检查函数调用是否有效了。

**内层作用域中的变量甚至可以掩盖外层作用域中同名的函数。反之，函数也可以掩盖变量。**

```c++
string read();
void print(const string &);
void print(double);

void fooBar(int ival){
    bool read = false;
    string s = read();    // 错误，read 变量掩盖了外层声明的read函数

    void print(int);
    print("Hello");    // 错误，print(const string &) 被隐藏了
    print(12.3);      // 调用了print(int);
    print(11);        // 调用了print(int);  
}

```

## 3. 函数匹配

大多数情况，很容易确定应该选用哪个重载函数。但是**当重载函数的形参数量相等以及某些形参的类型可以相互转换**，这就不是那么容易了。

### 3.1 函数匹配的步骤

1. 选定本次调用对应的重载函数集(**候选函数**)，一是与被调用的函数同名；二是其声明在调用点可见

2. 根据本次调用的实参，选出**可行函数**：一形参数量与本次调用提供的实参一致，二是每个实参的类型与对应的行参类型相同，或者能转换成行参的类型。

3. 如果没有找到可行函数，编译器将报告无匹配函数的错误。

4. 如果有多个可行函数，就寻找最佳的匹配。**实参类型和形参类型越接近，他们匹配的越好**

       如果有且只有一个函数满足以下条件，则匹配成功：
       1. 该函数的每个实参的匹配都不劣于其他可行函数需要的匹配
       2. 至少有一个实参的匹配优于其他可行函数提供的匹配。

5. 如果无法找到唯一的最佳匹配，编译器将包二义性调用错误。

```c++
void f();
void f(int);
void f(int, int);
void f(double, double = 3.14);

f(5.6);     // 可以找到最佳匹配，f(double,double)

f(3,14.5);  // f(int,int)和f(double,double) 之间无法确定最佳匹配，二义性调用告警

```

![](https://github.com/existorlive/existorlivepic/raw/master/%E6%88%AA%E5%B1%8F2020-09-27%20%E4%B8%8B%E5%8D%8811.41.56.png)

### 3.2 最佳匹配等级划分

为了确定最佳匹配，编译器将实参类型到形参类型的转化划分为几个等级：

1. 实参和形参能够精确匹配：
    
    - 实参类型和形参类型相同
    - 实参类型从数组类型或函数类型转换为对应的指针类型
    - 向实参添加顶层const或者从实参中删除顶层const

2. 通过const转换实现的匹配

```c++

Record lookUp(const Accout &);

Accout a;
lookUp(a);       // 常量引用可以绑定普通对象

```

3. 通过类型提升实现的匹配
   
```c++

void ff(short);
void ff(int);

ff('c');     // 'c'会提升为int 

```

4. 通过算术类型转换或指针转换
   
```c++
void manip(long);
void manip(float);

manip(3.14); // 3.14 既可以转为long，也可以转为double ， 二义性
```

5. 通过类类型转换实现的匹配。

