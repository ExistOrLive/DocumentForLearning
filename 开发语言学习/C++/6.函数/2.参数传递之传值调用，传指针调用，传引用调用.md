# 参数传递

## 1. 传值调用

**传值调用** 即形参类型不是指针类型或者引用类型，实参的值将被拷贝给形参，对于形参的修改不会反应到实参。


```c++

// 形参b不是指针类型或者引用类型，修改b不会影响实参
void changNum(int b){
    b++; 
}

int a = 11;
changNum(a);         
```

## 2. 传指针调用

**传指针调用** 形参类型为指针类型，实参的指针值被拷贝给形参，通过形参可以访问到实参指针所指向的对象。

形参和实参是两个不同的指针，但是指向同一个对象。

```c++

// a的地址赋值给形参b，通过b解指针可以修改a的值
void changNum(int *b){
    (*b)++; 
}

int a = 11;
changNum(&a);   

```

### Tip

> 在C语言中，使用指针类型的形参访问外部的对象，而在C++中提倡使用引用类型的形参代替指针

## 3. 传引用调用

**传引用调用** 形参为引用类型，使用实参初始化引用形参，引用形参绑定实参，对于引用形参的修改就是对实参的修改。

```c++
// 引用形参b绑定了实参a，修改b就是修改a
void changNum(int &b){
    b++; 
}

int a = 11;
changNum(a); 

```

### 3.1 使用引用可以避免拷贝
     
对于一些所占空间较大的对象或者容器类型，传值调用会拷贝这些对象的值，如果发生太多次无疑会带来性能问题。

甚至有一些类类型（如IO类型）的对象不支持拷贝操作。

### 3.2 使用引用形参返回额外的信息

对于一个函数来说，仅通过返回值返回信息，有时候是不够。我还可以通过引用形参返回额外的信息。


```c++

/**
 * fingChar函数 遍历字符串s中的字符，
 * 找到字符c第一次出现的位置并通过返回值返回；
 * 计算c出现的总次数，由引用形参cNum返回
 */
string::size_type findChar(const string &s, char c, string::size_type &cNum);

```
       

