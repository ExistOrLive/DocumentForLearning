# 移动操作

在某些情况下，对象拷贝后就立即被销毁了，此时移动而非拷贝对象将大幅度提高性能。

## 1. 右值引用

为了支持移动操作，新标准引入了一种新的引用类型-**右值引用**，右值引用绑定到右值上。

```c++
// c++ 使用 && 表示右值引用

int i = 42;
int &&p1 = i ;      // 报错，i不是右值
int &&p2 = i + 1;   // 正确，i+1的计算结果是一个临时对象，是右值

int &&p3 = p2;      // 报错，p2是一个左值

```

### 1.1 右值

右值指的不仅仅是只能出现在赋值运算符右边的对象，相对于左值，是一个短暂的临时对象。

- 对象即将被销毁
  
- 该对象没有其他的用户

右值要么是字面值，要么是表达式在求值过程中创建的临时对象或者函数返回的非左值引用对象。

#### Tip
  > 一个常量虽然也是只能出现在赋值运算符右边，但是它的生命周期可能没有很快结束，可能有很多地方使用，因此不是一个右值。

  > 变量是左值，因此我们不能将一个右值引用直接绑定到一个

### 1.2 move函数

标准库提供的`move`函数可以显式将一个左值转为对应的右值引用类型。定义在头文件`utility`中。

```c++
int i = 11;

int &&p1 = std::move(i);

```
调用了move之后的对象成为移后源对象，就交出了对象的管理权限，随时准备被销毁，因此它的值不再可靠，不可以再使用

> 对于移后源对象，我们可以销毁它，可以赋予它新的值，但是不可以在使用它的值。 


## 2. 移动构造函数和移动赋值运算符

### 2.1 移动构造函数

移动构造函数的第一个参数是右值引用，其他参数都有默认实参。

与拷贝构造函数不同，移动构造函数不分配新的内存，而会完全的窃取传入的移后源对象的数据结构，并要保证移后源对象处于销毁无害的状态。

```c++ 
class StrVec{
    std::string *elements;
    std::string *first_free;
    std::string *cap;
}

// 移动构造函数不应该抛出任何异常
StrVec::StrVec(StrVec &&s) noexcept : 
elements(s.elements),first_free(s.first_free),cap(s.cap){
    s.elements = s.first_free = s.cap = nullptr;    
    // 将指针置为空，即使s销毁也不会销毁被窃取的数据结构，即销毁无害的状态
}

```

### 2.2 移动的赋值运算符

移动赋值运算符包含了析构函数和移动构造函数的工作，同时还需要考虑自赋值的问题。

```c++
StrVec& StrVec::operator=(StrVec &&s) noexcept{
    // 首先检查是否自赋值
    if(this != &s){
        free();    // 释放原有的成员
        
        elements = s.elements;
        first_free = s.first_free;
        cap = s.cap;

        s.elements = s.first_free = s.cap = nullptr; 

    }
    return *this;
}

```

### 2.3 移动构造函数和移动赋值运算符不应该抛出异常

如果在移动过程中，抛出了异常，则移动过程被终止，一部分数据结构在移后源对象中，一部分在新的对象中。那么接下来程序如何执行将是未知的。

> 不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept

### 2.4 合成的移动构造函数和移动赋值运算符

只有当一个类没有显式定义任何的拷贝控制成员，且它所有的数据成员都可以移动构造或者赋值，编译器才会合成移动构造函数和移动赋值运算符。

```c++

// A 没有显式定义拷贝控制成员，可以合成移动构造函数和移动赋值运算符
struct A{
    int a;
    int b;
    std::vector<int> c;
};

A b(std::move(a));   

```

> 定义了一个移动构造函数或者移动赋值运算符的类必须定义自己的拷贝操作，否则这些成员默认定义为删除的

## 3. 右值引用和成员函数

### 3.1 右值引用作为成员函数参数

### 3.2 右值引用作为函数的调用者

通常情况下，一个对象调用成员函数，不管该对象是一个左值还是右值。

有时希望强制保证调用者是一个左值，而不是一个临时的右值。

使用引用限定符&在成员函数的参数列表后，且必须同时出现在函数的生命和定义中。

```c++
class Foo{
    public:
    // 在参数列表后加 & ，表明函数调用者只能是左值
    // 只能向可修改的左值赋值
    Foo &operator=(const Foo&) &;
}

Foo &operator=(const Foo&) &{
    return *this;
}

```

#### 引用限定符和重载

如同成员函数和常量成员函数，相同的函数名，形参列表，但是不同的引用限定符会构成重载。

```c++
class Foo{
    public:
   
    // 函数调用者只能是左值
    Foo &operator=(const Foo&) &;
    // 函数调用者只能是右值
    Foo &operator=(const Foo&) &&;
    // 函数调用者只能常量左值
    Foo &operator=(const Foo&) const &;
}

```

> 如果一个成员函数有引用限定符，则具有相同的参数列表的所有版本都必须有引用限定符。


## 4. 值类型，左值引用类型和右值引用类型作为参数的对比

- 值类型作为参数会被完全拷贝一份一摸一样的对象

- 左值引用 是直接使用传入的对象

- 右值引用 是抢占传入对象的资源


类比需要使用某种计算器：

- 值类型是买一个一摸一样的使用，开销大

- 左值引用则是借一个计算器使用，使用后归还

- 右值引用则是抢来一个计算器使用，不再归还，别人不能再使用












