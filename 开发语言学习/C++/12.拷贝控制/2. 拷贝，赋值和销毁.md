# 拷贝，赋值和销毁

---

## 1. 拷贝构造函数

如果一个构造函数的第一个参数是自身类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。

- 拷贝构造函数第一个参数必须是引用

- 拷贝构造函数不应该是explicit

```c++
class Demo{

string a;
int b;
int arr[10];
const int c;

public:
      Demo(const Demo &);
}
```

### 1.1 合成的拷贝构造函数

如果没有显式定义拷贝构造函数，编译器会生成**合成的拷贝构造函数**。

**合成的拷贝构造函数**会将对象的非静态数据成员逐个拷贝到正在创建的对象中。

对于类类型的数据成员，会使用拷贝构造函数来拷贝；
内置类型的成员则直接拷贝；
对于数组类型的成员，合成构造函数会逐个拷贝它的元素。


```c++
// 合成的拷贝运算符代码同下
Demo::Demo(const Demo &demo):a(demo.a),b(demo.b),c(demo.c){
    for(size_t i = 0; i < 10; ++i){
        this->arr[i] = demo.arr[i];
    }
}

```

---

## 2. 拷贝赋值运算符

当使用一个类类型对象赋值另一个类类型相同的对象，就是调用赋值运算符。

### 2.1 重载赋值运算符

重载运算符本质上是一个函数，其名字由`operator`关键字加上运算符组成。

赋值运算符就是名为`operator=`的函数，返回值是类类型的引用，形参是一个const类类型的引用。

> 赋值运算符在重载过程中，需要注意自赋值的问题；

> 赋值运算符其实相当于析构函数和拷贝构造函数一起的工作,需要销毁原本对象的资源，再将目标对象的资源拷贝过来。

```c++
class Demo{
private:

string a;
int b;
int arr[10];
string *d;


public:
Demo& operator=(const Demo& demo);   // 重载赋值运算符
}

Demo& Demo::operator=(const Demo& demo){
    if(this == &demo){
        return *this;      // 处理自赋值     
    }

    string *tmpD = new string(*(demo.d));  // 首先拷贝资源
     
    delete this->d;                   // 销毁自己的资源   相当于析构函数的工作
    this->d = tmpD;                   // 拷贝资源
    this->a = demo.a;
    this->b = demo.b;
     for(size_t i = 0; i < 10; ++i){
        this->arr[i] = demo.arr[i];
    }
}

```

### 2.2 合成的拷贝赋值运算符

当我们没有显式地去重载拷贝赋值运算符，编译器会生成**合成的拷贝赋值运算符**。

**合成的拷贝赋值运算符**和**合成的拷贝赋值运算符**一致，将目标对象的每个非static数据成员拷贝过来，对于数组类型的成员会逐个元素拷贝。

```c++
// 合成的拷贝赋值运算符功能等同于以下代码
Demo& Demo::operator=(const Demo& demo){
    this->a = demo.a;
    this-b = demo.b;
    for(size_t i = 0; i < 10; ++i){
        this->arr[i] = demo.arr[i];
    }
}

```

---

## 3. 析构函数

析构函数与构造函数相反的操作：

构造函数初始化对象的非static数据成员，还可能做一些其他工作。

析构函数释放对象使用的资源，并销毁对象的非static数据成员。

### 3.1 析构函数的工作

构造函数可以分为初始化部分和函数体；析构函数也可以分为函数体和析构部分。

在构造函数中，成员的初始化在函数体执行之前完成，且按照他们在类中的定义顺序进行初始化；

在析构函数中，首先执行函数体，再执行析构部分，成员按照初始化的顺序逆序销毁。

### 3.2 合成的析构函数

当一个类未定义自己的析构函数，编译器会定义一个**合成的析构函数**。**合成的析构函数**的函数体为空。

--- 

## 4. 三/五法则

> 如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义的拷贝赋值运算符和拷贝构造函数

> 需要拷贝操作的类也需要赋值操作，反之亦然


---

## 5. 阻止拷贝

虽然大多数类应该定义拷贝构造函数和拷贝赋值运算符，但是对于一些类来说，这些操作没有意义。因此需要某种机制阻止拷贝和赋值。例如，iostream类阻止了拷贝和赋值。

### 5.1 定义删除的函数

在函数的参数列表后面加上=delete来指出我们希望将它定义为删除

=delete必须出现在函数第一次声明的时候

```c++
class Demo{
    public:
    Demo() = default;                 // 默认的构造函数
    Demo(const Demo&) = delete;       // 将拷贝构造函数定义为删除，阻止拷贝
    Demo& operator=(const Demo&) = delete; // 将拷贝赋值运算符定义为删除，阻止赋值
}
```

### 5.2 析构函数不能够定义为删除

对于一个删除了析构函数的类，不能定义该类型的变量或释放指向该类型动态分配对象的指针。

### 5.3 合成的析构，拷贝构造，赋值运算符可能是delete的

- 如果类的某个数据成员不能拷贝，赋值或者销毁，类对应的合成函数就是删除的

- 如果类的某个数据成员是const或者是引用，它的拷贝赋值运算符是删除的，但是拷贝构造函数可以合成

- 如果类的某个数据成员是const或者是引用，且没有定义对应的类内初始化器，则该类的默认构造函数无法合成


### 5.3 private拷贝控制

可以将拷贝构造函数声明为private，阻止拷贝。












