# Swift集合高级知识
#Swift 
#集合

![](http://pic.existorlive.cn//202205171521533.png)

## 1. Sequence

**Sequence** 是一种提供了对其元素的顺序迭代访问的类型。 

```swift 
public protocol Sequence {

    /// A type representing the sequence's elements.
    associatedtype Element where Self.Element == Self.Iterator.Element

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    associatedtype Iterator : IteratorProtocol

    /// Returns an iterator over the elements of this sequence.
    func makeIterator() -> Self.Iterator

    var underestimatedCount: Int { get }

    func withContiguousStorageIfAvailable<R>(_ body: (UnsafeBufferPointer<Self.Element>) throws -> R) rethrows -> R?
}
```

### 1.1 Sequence的基本性质及扩展 

**Sequence** 是一组元素列表，可以按顺序逐个的去访问。常用的方法就是通过 `for-in`循环去遍历元素。
```swift
let oneTwoThree = 1...3
for number in oneTwoThree {
       print(number)
}
```

尽管能够按序遍历的性质很简单，但是衍生出了大量的操作。 例如，查询序列中是否包含某个元素，即`contains(_:)` 提供的能力。 这些操作都是通过 `Sequence` 的标准库扩展来提供默认实现。

```swift
extension Sequence {

.......

// 遍历
@inlinable public func forEach(_ body: (Self.Element) throws -> Void) rethrows

// 转换
@inlinable public func map<T>(_ transform: (Self.Element) throws -> T) rethrows -> [T]

// 过滤
@inlinable public func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> [Self.Element]

......
}
```

### 1.2 不可重复访问
`Sequence` 协议不要求实现它的类型是否能够重复的，多次的去遍历元素。因此，我们不能够认为每次对 `Sequence`对象进行`for - in` 遍历，都能够从第一个元素重新开始。

```swift
for element in sequence {
	if ... some condition { break }
}

// 再次遍历不能确保能够访问元素 
for element in sequence {
     // No defined behavior
}
```

如果需要支持重复的，多次的去遍历元素，需求要去实现`Collection`协议

### 1.3 实现Sequence协议
为自定义类型实现`Sequence`协议时，需要提供`func makeIterator() -> Self.Iterator` 方法。`func makeIterator() -> Self.Iterator` 返回一个**迭代器**(`IteratorProtocol`)对象，通过迭代器可以逐个遍历Sequence的元素。

### 1.4 期望的性能

`Sequence`需要在O(1)的时间复杂度内提供**迭代器**(`IteratorProtocol`)对象。 `Sequence` 对元素的访问没有任何要求，因此惯例遍历 `Sequence`的时间复杂度应该是 O(n). 

## 2. Collection 
`Collection` 继承于 `Sequence`, 是一种可以多次，非摧毁式的遍历元素以及支持索引下标访问元素的 `Sequence`

`Collection` 在标准库中广泛的使用；当使用 `Array`，`Dictionary` 或者其他集合类型时，都得益于 `Collection` 协议中声明或者定义的操作。`Collection` 协议除了继承自 `Protocol` 协议的操作，还支持访问集合中指定位置元素的操作。


```swift
public protocol Collection {

    @available(*, deprecated, message: "all index distances are now of type Int")
    typealias IndexDistance = Int

    associatedtype Element
    
    associatedtype Index : Comparable where Self.Index == Self.Indices.Element, Self.Indices.Element == Self.Indices.Index, Self.Indices.Index == Self.SubSequence.Index, Self.SubSequence.Index == Self.Indices.Indices.Element, Self.Indices.Indices.Element == Self.Indices.Indices.Index, Self.Indices.Indices.Index == Self.SubSequence.Indices.Element, Self.SubSequence.Indices.Element == Self.SubSequence.Indices.Index, Self.SubSequence.Indices.Index == Self.Indices.Indices.Indices.Element, Self.Indices.Indices.Indices.Element == Self.Indices.Indices.Indices.Index, Self.Indices.Indices.Indices.Index == Self.SubSequence.Indices.Indices.Element, Self.SubSequence.Indices.Indices.Element == Self.SubSequence.Indices.Indices.Index, Self.SubSequence.Indices.Indices.Index == Self.SubSequence.Indices.Indices.Indices.Element, Self.SubSequence.Indices.Indices.Indices.Element == Self.SubSequence.Indices.Indices.Indices.Index

    var startIndex: Self.Index { get }

    var endIndex: Self.Index { get }

    associatedtype Iterator = IndexingIterator<Self>

    override func makeIterator() -> Self.Iterator
    
    associatedtype SubSequence : Collection = Slice<Self> where Self.Element == Self.SubSequence.Element, Self.SubSequence == Self.SubSequence.SubSequence

    subscript(position: Self.Index) -> Self.Element { get }

    subscript(bounds: Range<Self.Index>) -> Self.SubSequence { get }

    associatedtype Indices : Collection = DefaultIndices<Self> where Self.Indices == Self.Indices.SubSequence

    var indices: Self.Indices { get }

    var isEmpty: Bool { get }
    
    var count: Int { get }

    func index(_ i: Self.Index, offsetBy distance: Int) -> Self.Index

    func index(_ i: Self.Index, offsetBy distance: Int, limitedBy limit: Self.Index) -> Self.Index?

    func distance(from start: Self.Index, to end: Self.Index) -> Int

    func index(after i: Self.Index) -> Self.Index


    func formIndex(after i: inout Self.Index)
}
```
### 2.1 访问单个元素
Collection 支持任意合法的index(除了endIndex)通过下标表示法访问单个元素，

```swift
let firstChar = text[text.startIndex]
```

Collection 在通过下标任意访问单个元素的基本性质之上，声明和实现了许多操作。如 `first` 属性

```swift
print(text.first)
```

Collection 只能够接收合法的index。 一个 Collection对象的合法index 从 startIndex 开始直到 endIndex。

一个 Collection 对象的合法index对于另一个 Collection 对象来说是非法的。保存一个Collection对象的合法index 在修改了Collection之后，可能会变成非法的。

### 2.2 访问集合的切片
你可以通过范围下标或者调用 `prefix(while:) ` `suffix(_:)` 等方法访问Collection对象的切片。 切片包含0个或者多个原始Collection对象的元素，并且与原始Collection对象共享底层的数据。

```swift
let firstWord = text.prefix(while: { $0 != " " })
print(firstWord)
// Prints "Buffalo"

if let firstSpace = text.firstIndex(of: " ") {
    print(text[..<firstSpace]
    // Prints "Buffalo"
}
```

### 2.3 集合对象和切片共享index
Collection 对象和它的切片共享一组index。当一个切片被创建时，Collection对象和已存在的切片都没有被修改，index也没有被修改。

```swift
        let array = [1,2,3,3,4]
        let slice = array[0..<2]
        
        if let index = array.lastIndex(of: 2) {
            print(array[index])
            // 集合对象的index对切片是合法的
            print(slice[index])
        }
```

注意当Collection对象或者切片被修改后，共享的index对于Collection对象和切片不一定是合法的

### 2.4 切片和集合的写时拷贝
Collection对象的切片在刚创建出来时，和原始的Collection对象共享底层的数据结构。但是Collection对象或者切片修改后，就会触发写时拷贝。如 Collection对象在修改后，并不会影响之前生成的切片

```swift
     .  var array = [1,2,3,3,4]
        var slice = array[0..<2]
        
        slice[0] = 11
        
        // [1, 2, 3, 3, 4]
 .      // [11, 2]
        print(array)
        print(slice)
        
        
        array[0] = 12
        // [12, 2, 3, 3, 4]
        // [11, 2]
        print(array)
        print(slice)
```

### 2.5 遍历集合对象
Sequence 对象在遍历后，元素可能会被消费掉，因此 Sequence 对象的元素只能够访问一次；而 Collection 对象的元素支持多次，非摧毁式地访问。

Collection对象通过下标遍历元素，和 通过迭代器来遍历元素产生的结果是一样的。

```swift
       let array = [1,2,3,3,4]
        
        for element in array {
            print(element)
        }
        
        for index in array.indices {
            print(array[index])
        }
```

### 2.6 实现Collection协议

实现Collection协议，首先要实现 Sequence 协议，并且保证元素可以多次的，非摧毁式地访问。

另外需要实现以下的属性和方法

-  `startIndex` 和 `endIndex` 属性
- `subscript` 方法至少支持只读访问元素
- `index(after:)` 方法移动index

### 2.7 期望的性能
实现`Collection`协议，调用 `startIndex` ，`endIndex` 和 通过下标访问元素的时间复杂度应该是 O(1) 。 因此 `Collection` 协议扩展的许多操作都依赖于 O(0) 的下标访问。

一些集合操作的性能依赖于 index 的类型。例如 支持的随机访问的Collection类型，计算index之间的距离和集合长度的时间复杂度为O(1); 而 支持前向或者双向的Collection类型必须遍历集合才能计算集合的长度，因此时间复杂度为O(n)


## 3.  BidirectionalCollection
支持双向遍历的集合

```swift
protocol BidirectionalCollection where Self.Indices : BidirectionalCollection, Self.SubSequence : BidirectionalCollection
```


## IteratorProtocol

`IteratorProtocol`  指一次提供一个元素值的类型。`IteratorProtocol` 按顺序访问元素，调用`next()`返回一个元素，并前进一步。 

```swift 
public protocol IteratorProtocol {

    associatedtype Element

    ///     let numbers = [2, 3, 5, 7]
    ///     var numbersIterator = numbers.makeIterator()
    ///
    ///     while let num = numbersIterator.next() {
    ///         print(num)
    ///     }

    mutating func next() -> Self.Element?
}
```

`IteratorProtocol` 和 `Sequence` 协议紧密关联，`Sequence` 通过迭代器对象提供对元素的访问。迭代器对象能够遍历序列一次返回一个元素。

无论使用`for - in` 遍历 `Array`,`Set` 或者任何其他集合或序列, 内部都是通过迭代器来实现的。 

```swift
let animals = ["Antelope", "Butterfly", "Camel", "Dolphin"]
for animal in animals {
	print(animal)
}

// 等同于

var animalIterator = animals.makeIterator()
while let animal = animalIterator.next() {
	print(animal)
}

```

注意每次调用`Sequence` 的`makeIterator()`都返回一个独立的迭代器对象，