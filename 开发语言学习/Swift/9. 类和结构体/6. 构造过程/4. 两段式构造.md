# 两段式构造过程

C++，OC，Swift在构造过程都是遵循两段式的构造过程

## 1. C++构造过程

C++ 构造过程分为数据成员初始化和构造函数函数体两个部分：

- 首先初始化所有的数据成员

    - 按照数据成员声明的顺序逐个初始化
         
         - 初始值可能是由初始化列表提供
         - 也可能由类内初始值提供
         - 未提供初始值，则默认初始化(基本数据类型默认初始化值是未定义的)


- 在构造函数函数体中进行进一步的初始化

    - 执行到构造函数函数体中，当前类的每个数据成员都已经初始化完毕，处于可以安全使用的状态。(子类的数据成员此刻还没有初始化)

```c++ 
    // 先调用父类的构造函数，在初始化当前类的数据成员 
    Test1():Test(),a(12){
        
    }

```

## 2. OC构造过程

OC中每一个属性都会在执行init方法之前，默认初始化

- 首先默认初始化所有的属性
   
    - 类类型默认初始化为nil
    - 基本类型默认初始化为0，NO等

- 在init中进行进一步的初始化


## 3. Swift构造过程

C++和OC构造过程在执行到构造函数或者init方法时，数据成员或者属性都已经初始化完毕，可以在构造器中任意使用各个数据成员。


`Swift`的构造过程也是遵循两段式；但是由于`Swift`中的存储属性(除了可选类型)必须显式初始化才能够使用，且初始化时机可以放在构造器函数体中。

这里就需要开发者在构造器中有意识的将两个部分切割开来；同时Swift的编译器也会进行一些安全检查：

    
1. 指定构造器必须保证它所在类的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中的构造器。

       父类的构造器在完成存储属性初始化后，可能会调用其他的方法。
       这些方法也许被子类重写，在其中访问子类的属性。
       因此必须保证调用父类的指定构造器时初始化子类的所有属性。

2. 指定构造器必须在为继承的属性设置新值之前向上代理调用父类构造器。如果没这么做，指定构造器赋予的新值将被父类中的构造器所覆盖。

3. 便利构造器必须为任意属性（包括所有同类中定义的）赋新值之前代理调用其它构造器。如果没这么做，便利构造器赋予的新值将被该类的指定构造器所覆盖。

4. 构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用 self 作为一个值。


## 4. C++/OC/Swift构造过程对比

C++/OC/Swift 的构造过程都是两段式：

- 第一阶段 初始化所有的数据成员(之后数据成员都处于初始化后的安全状态)

- 第二阶段 在第一阶段后所有成员都是可以任意访问的安全状态，做进一步的初始化

不同的是，C++/OC的数据成员大多可以隐式的默认初始化；而Swift中的属性(除了可选类型)则必须显式初始化。不讨论在定义数据成员时提供初始值的情况，C++/OC将第一阶段的过程放在了构造器函数体之前；而Swift则必须在函数体中处理第一阶段。

这里就需要开发者在构造器中有意识的将两个阶段割开来；同时Swift的编译器也会通过安全检查来提供辅助。

有一点需要注意：由于多态性，在父类构造器中也可以能会访问到子类的数据成员：

在C++的构造函数中不会发生多态，因此避免了这个问题；

在OC中进入到init函数体时，所有的数据成员(包括子类和父类的数据成员)事实上已经默认初始化，因此都可以安全访问

在Swift中，有这样一条安全检查： 在子类指定构造器中，必须先初始化所有的子类存储属性，才能再代理到父类的构造器。因此在父类的构造器中访问子类成员是安全的。


```C++

// C++
class Test{
    int a;
    Test(int a):a(a){
        testFunc();           // C++在构造器中不会发生动态调用
    }

    virtual void testFunc(){
        cout << a;
    }
};

class Test1 : Test {
    int b;
    Test1(int b):Test(12),b(b){

    }

    virtual void testFunc() override {
        cout << b;
    }
};

Test1 b;


```

```swift

// swift
class Test{
    var a : Int
    
    init(){
        a = 11
        testFunc()        // 多态，调用到子类重写的实现
    }

    func testFunc(){
        print(a)
    }
}

class Test1 : Test {
    
    var b : Int

    init(){
        b = 13              // 先初始化子类的存储属性
        super.init()        // 再代理父类构造器
    }

    override func testFunc(){
        print(b)
    }
}

let b = Test1()


```














