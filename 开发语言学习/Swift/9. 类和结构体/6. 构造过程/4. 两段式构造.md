# 两段式构造过程

C++，OC，Swift在构造过程都是遵循两段式的构造过程

## 1. C++构造过程

C++ 构造过程分为数据成员初始化和构造函数函数体两个部分：

- 首先初始化所有的数据成员

    - 按照数据成员声明的顺序逐个初始化
         
         - 初始值可能是由初始化列表提供
         - 也可能由类内初始值提供
         - 未提供初始值，则默认初始化(基本数据类型默认初始化值是未定义的)


- 在构造函数函数体中进行进一步的初始化

    - 执行到构造函数函数体中，当前类的每个数据成员都已经初始化完毕，处于可以安全使用的状态。(子类的数据成员此刻还没有初始化)

```c++ 
    // 先调用父类的构造函数，在初始化当前类的数据成员 
    Test1():Test(),a(12){
        
    }

```

## 2. OC构造过程

OC中每一个属性都会在执行init方法之前，默认初始化

- 首先默认初始化所有的属性
   
    - 类类型默认初始化为nil
    - 基本类型默认初始化为0，NO等

- 在init中进行进一步的初始化


## 3. Swift构造过程

C++和OC构造过程在执行到构造函数或者init方法时，数据成员或者属性都已经初始化完毕，可以在构造器中任意使用各个数据成员。


`Swift`的构造过程也是遵循两段式；但是由于`Swift`中的存储属性(除了可选类型)必须显式初始化才能够使用，且初始化时机可以放在构造器函数体中。

这里就需要开发者在构造器中有意识的将两个部分切割开来；同时Swift的编译器也会进行一些安全检查：

    
1. 指定构造器必须保证它所在类的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中的构造器。

       父类的构造器在完成存储属性初始化后，可能会调用其他的方法。
       这些方法也许被子类重写，在其中访问子类的属性。
       因此必须保证调用父类的指定构造器时初始化子类的所有属性。

2. 指定构造器必须在为继承的属性设置新值之前向上代理调用父类构造器。如果没这么做，指定构造器赋予的新值将被父类中的构造器所覆盖。

3. 便利构造器必须为任意属性（包括所有同类中定义的）赋新值之前代理调用其它构造器。如果没这么做，便利构造器赋予的新值将被该类的指定构造器所覆盖。

4. 构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用 self 作为一个值。












