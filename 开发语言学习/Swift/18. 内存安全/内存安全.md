# 内存安全

默认情况下，Swift 会阻止你代码里不安全的行为。例如，Swift 会保证变量在使用之前就完成初始化，在内存被回收之后就无法被访问，并且数组的索引会做越界检查。

**Swift 也保证同时访问同一块内存时不会冲突，通过约束代码里对于存储地址的写操作，去获取那一块内存的访问独占权.**

因为 Swift 自动管理内存，所以大部分时候你完全不需要考虑内存访问的事情。然而，理解潜在的冲突也是很重要的，可以避免你写出访问冲突的代码。而如果你的代码确实存在冲突，那在编译时或者运行时就会得到错误


## 内存访问冲突

内存访问的冲突会发生在你的代码尝试同时访问同一个存储地址的时候。同一个存储地址的多个访问同时发生会造成不可预计或不一致的行为。

在多线程编程的情况下，同时访问同一地址段造成的内存冲突其实很好理解。但是这里我们讨论的是单一线程的情况下。

在访问内存时，我们要考虑三个问题：

- 访问是读操作还是写操作
- 访问的时长
- 被访问的地址

多数的访问是瞬时的；在瞬时访问期间，不会同时存在对同一地址的访问，也就是说瞬时访问不会有内存冲突。

单纯的读操作，即便是多次同时的，也不会发生内存访问冲突。

**Swift的内存访问冲突指的是在对某个地址发生长期写访问期间，又发生了对同一地址的访问(不论该访问是写还是读，不论是瞬时还是长期的)**

> 如果你曾经在单线程代码里有访问冲突，Swift 可以保证你在编译或者运行时会得到错误.


## 长期写访问的几种场景

- 使用 inout 参数的函数

- 结构体的mutating方法

- 捕获变量的闭包


## Inout参数的访问冲突

一个函数会对它所有的 `inout` 参数进行长期写访问。`inout` 参数的写访问会在所有非 `inout` 参数处理完之后开始，直到函数执行完毕为止。如果有多个 `inout` 参数，则写访问开始的顺序与参数的顺序一致。

- 长期访问的存在会造成一个结果，你不能在访问以 in-out 形式传入后的原变量，即使作用域原则和访问权限允许——任何访问原变量的行为都会造成冲突。

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-02-03%20%E4%B8%8B%E5%8D%881.59.14.png)

```

Simultaneous accesses to 0x100008170, but modification requires exclusive access.

```

这里 全局变量a 作为 inout参数 传入 函数someFunction，但是在 函数someFunction 中又对 全局变量a 发生了瞬时读操作


- 往同一个函数的多个 in-out 参数里传入同一个变量也会产生冲突

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-02-03%20%E4%B8%8B%E5%8D%882.15.11.png)

## 值类型的mutating函数的访问冲突

在值类型的mutating方法调用期间，对于 `self` 也是长期写访问。

因此在对值类型对象的mutating方法调用期间，不能够再对该对象发生其他访问。

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-02-03%20%E4%B8%8B%E5%8D%882.27.06.png)


### 值类型的属性访问冲突

对于值类型来说，修改值的任何一部分都是对于整个值的修改，意味着其中一个属性的读或写访问都需要访问整一个值。

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-02-03%20%E4%B8%8B%E5%8D%882.35.52.png)


## 闭包的访问冲突

Swift中的闭包捕获变量的方式是引用捕获，因此**在闭包执行期间就是对捕获变量的长期写访问**

因此在闭包的执行期间，不可以在发生对于捕获变量的访问。

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-02-03%20%E4%B8%8B%E5%8D%882.39.34.png)


## 总结

- Swift的内存访问冲突是指 **在对一块内存进行长期写访问期间，再次发生了对同一块的内存的访问**

- 内存访问冲突是在单线程的场景下讨论的 


- 发生长期写访问的场景

   - 使用 inout 参数的函数，对于inout参数是长期写访问

   - 值类型的mutating方法，对于self是长期写访问

   - 捕获变量的闭包，对于捕获变量是长期写访问



