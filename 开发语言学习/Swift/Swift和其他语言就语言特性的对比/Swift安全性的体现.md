# Swift安全性的体现

Swift的安全性

## 1. Swift中的变量或常量在使用前必须初始化

Swift中的变量或常量在使用前必须初始化，否则无法通过编译

- 全局变量和类型变量必须提供初始化器。

- 局部变量必须在使用前初始化，否则无法通过编译

- 实例变量必须提供初始化器或者在构造器中完成初始化

不会出现像C/C++中使用未初始化的变量导致未定义结果的问题。


## 2. Swift中的类型转换

C/C++，OC语言在算术运算中，会隐式地将运算对象转换为相同的类型才计算，溢出时也只会截取对应位数上的数据。所以经常会发生计算结果和预期不一致的情况。

特别是C++，通过转换构造函数和转换运算符的重载，还支持类类型之间的隐式转换，更是增加了由于隐式类型转换导致错误的几率。


C++/OC/swift 中具有继承关系的对象可以转换。

C++/Objc中的类型转换，仅在编译器做检查，只要符合转换规则，就可以通过。
而 Swift 中的类型转换在运行时做检查，判断能够转换成功。


```c++
class SuperClass{
    void test(){
        cout << "SuperClass";
    }
};

class SubClass : public SuperClass{
    void subtest(){
        cout << "SubClass";
    }
};


int main(){
    SuperClass a;
    SuperClass *aPoint = a;
    ((SubClass *)aPoint)->subtest();  // 仅在编译期检查，运行时可能会出错
}

```


```c++
class SuperClass{
    func test(){
        print("SuperClass")
    }
};

class SubClass : public SuperClass{
    func subtest(){
        print("SubClass")
    }
};

let a = SuperClass();
if let b = a as? SubClass{   // 运行时检查不会报错
    b.subtest()
}

```


## 3. Swift在继承和重写上的安全

Swift中的子类在继承父类时，不会添加相同类型相同名字的成员

Swift中子类中声明了与父类名字相同的成员一定是重写父类成员，并必须使用`override`声明。

- 在OC中，重写父类成员不需要显示地声明`override`。子类中定义成员是否会对父类的重写很多时候很模糊。
- 在OC中定义了与父类相同名字的方法，即便该方法对子类不可见，一定就是重写。



## 4. 闭包会管理捕获的变量或常量的生命周期

闭包会管理捕获的变量或常量的生命周期，因此在闭包中使用常量或变量，不需要要考虑它是否已经销毁。

在C++中实现的`lambda`表达式，则不会去管理引用捕获的变量，需要程序员在开发中注意

## 5. 自动的内存管理

在Swift中，对于引用类型的对象会使用自动引用计数管理对象的生命周期


## 6. 两段式的构造过程

Swift中类的构造过程基本上可以分为两个部分：一是为初始化类中所有的存储属性(确保没有属性处于未定义的状态)，二则是进一步进行初始化工作。

Swift引入`指定构造器`和`便利构造器`，同时会对自定的构造器安全检查。

构造器的定义应该遵守三条规则和符合安全检查

- 指定构造器必须调用其直接父类的的指定构造器。
  
- 便利构造器必须调用同类中定义的其它构造器。

- 便利构造器最后必须调用指定构造器。


![](https://github.com/existorlive/existorlivepic/raw/master/initializerDelegation01_2x.png)

安全检查：

-  指定构造器必须保证它所在类的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中的构造器。

- 指定构造器必须在为继承的属性设置新值之前向上代理调用父类构造器。如果没这么做，指定构造器赋予的新值将被父类中的构造器所覆盖。

- 便利构造器必须为任意属性（包括所有同类中定义的）赋新值之前代理调用其它构造器。如果没这么做，便利构造器赋予的新值将被该类的指定构造器所覆盖。

- 构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用 self 作为一个值。


