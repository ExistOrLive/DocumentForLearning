# GLUT用例简述

## GLUT框架

**GLUT** 代表OpenGL应用工具包，英文全称为OpenGL Utility Toolkit，是一个和窗口系统无关的软件包。接下来通过使用GLUT框架的Demo来描述OpenGL相关的概念。

[GLUT用例](https://github.com/ExistOrLive/DemoForLearning/tree/master/%E8%A7%86%E8%A7%89%E7%9B%B8%E5%85%B3/001--OpenGL%E5%9B%BE%E5%85%83%E7%BB%98%E5%88%B6(%E7%BB%BC%E5%90%88))

该Demo使用 GLTools 静态库，该库中集成顶点，着色器等API

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-01-10%20%E4%B8%8A%E5%8D%8812.28.41.png)


## 1. GLUT代码流程简述

### 1. 在main函数中初始化GLUT

在使用**GLUT**相关API之前需要初始化

```c++

    /**
     * 设置工作目录 
     **/
    gltSetWorkingDirectory(argv[0]);

    /**
     * 初始化GLUT 
     **/
    glutInit(&argc, argv);

    /**
     * 设置帧缓冲区相关参数
     *  GLUT_DOUBLE 双缓冲区
     *  GLUT_RGBA   颜色缓冲区
     *  GLUT_DEPTH  深度缓冲区
     *  GLUT_STENCIL 模版缓冲区
     **/
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH | GLUT_STENCIL);


    //设置window 的尺寸
    glutInitWindowSize(800, 600);
    //创建window的名称
    glutCreateWindow("GL_POINTS");

    /**
     *  GLUT 内部运行一个本地消息循环，拦截适当的消息。然后调用我们不同时间注册的回调函数。
     * 注册事件回调函数
     * 注册窗口大小修改的回调函数
     * 注册渲染的函数
     **/

    //注册回调函数（改变尺寸）
    glutReshapeFunc(ChangeSize);
    //点击空格时，调用的函数
    glutKeyboardFunc(KeyPressFunc);
    //特殊键位函数（上下左右）
    glutSpecialFunc(SpecialKeys);
    //显示函数
    glutDisplayFunc(RenderScene);

```

测试GLUT框架是否能够正常使用：

```c++  
    //判断一下是否能初始化glew库，确保项目能正常使用OpenGL 框架
    GLenum err = glewInit();
    if (GLEW_OK != err) {
        fprintf(stderr, "GLEW Error: %s\n", glewGetErrorString(err));
        return 1;
    }

```

初始化着色器； 

```c++

// GLShaderManager shaderManager;

// 初始化着色器
shaderManager.InitializeStockShaders();

```

设置模型矩阵，透视矩阵以及观察者矩阵；

```c++
//几何变换的管道，用于模型矩阵，透视矩阵的计算
// GLGeometryTransform	transformPipeline;

// 模型矩阵和透视矩阵
// GLMatrixStack		modelViewMatrix;
// GLMatrixStack		projectionMatrix;

// 观察者视角信息
// GLFrame				cameraFrame;


transformPipeline.SetMatrixStacks(modelViewMatrix, projectionMatrix);

// 设置观察者视角
cameraFrame.MoveForward(-15.0f);

```

初始化图形的顶点信息：

```c++

// GLBatch类 保存顶点信息和连线方式

    GLfloat vCoast[9] = {
        3,3,0,0,3,0,3,0,0
        
    };
    
    //用点的形式
    pointBatch.Begin(GL_POINTS, 3);
    pointBatch.CopyVertexData3f(vCoast);
    pointBatch.End();

```

启动消息循环

```c++
    glutMainLoop();
```


### 2. 设置窗口尺寸变化的回调函数

`glutReshapeFunc(ChangeSize);`设置`ChangeSize`函数为窗口尺寸变化的回调函数

在`ChangeSize`函数中设置视口大小和投影矩阵

```c++

// 窗口已更改大小，或刚刚创建。无论哪种情况，我们都需要
// 使用窗口维度设置视口和投影矩阵.
void ChangeSize(int w, int h)
{
    // 设置视口大小
    glViewport(0, 0, w, h);


    //创建投影矩阵，并将它载入投影矩阵堆栈中
    viewFrustum.SetPerspective(35.0f, float(w) / float(h), 1.0f, 500.0f);
    projectionMatrix.LoadMatrix(viewFrustum.GetProjectionMatrix());
    
    //调用顶部载入单元矩阵
    modelViewMatrix.LoadIdentity();
}



```


### 3. 绘制图形的回调函数

`glutDisplayFunc(RenderScene);` 设置 `RenderScene()` 为渲染图形的回调函数。

- 首先清空帧缓冲区
  
```c++ 

// Clear the window with current clearing color
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);

```

-  


## 2. 坐标系相关概念

我们在给着色器传递的顶点信息是以图形本身为坐标系，即**对象坐标系**。

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-01-10%20%E4%B8%8A%E5%8D%881.49.45.png)

而显示在屏幕上的画面是以屏幕为坐标系，即**屏幕坐标系**。

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-01-10%20%E4%B8%8A%E5%8D%881.48.57.png)

为了最终将图形显示在屏幕上，需要将**对象坐标系**转换为**屏幕坐标系**。该过程包括**模型转换**，**视角变换**，**投影变换**，**视口裁剪**，**视口变换**。

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-01-10%20%E4%B8%8A%E5%8D%881.31.55.png)

**模型变换** ： 即平移，伸缩和旋转等变换；将**对象坐标系**转换为**世界坐标系**

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-01-10%20%E4%B8%8A%E5%8D%881.49.38.png)

**视角变换** ： 通过观察者视角转换为**观察者坐标系**

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-01-10%20%E4%B8%8A%E5%8D%881.49.30.png)
**投影变换** ： 将3D坐标转换为2D坐标

**视口裁剪** ： 根据视口裁剪掉无法看到部分，得到**规范设备坐标系**

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-01-10%20%E4%B8%8A%E5%8D%881.49.19.png)

**视口变换** ： 将**规范设备坐标系**转换为**屏幕坐标系**
 

### 坐标系的矩阵计算

坐标系的变换其实是一系列的矩阵计算：

###

顶点数据 * 模型矩阵 * 视角矩阵 * 透视矩阵

###

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-01-10%20%E4%B8%8A%E5%8D%881.55.04.png)






