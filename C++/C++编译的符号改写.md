### C++编译的符号改写
> 作为面向对象的语言，C\+\+为了支持函数重载，函数在被C\+\+编译后在符号库中的名字与C语言的不同。假如某个函数的原型为void foo(int x, int y);该函数被C编译器编译后在符号库中的名字为_foo，而C\+\+编译器则会产生_foo_int_int之类的名字。_foo_int_int这样的名字是包含了函数名以及形参，C++就是靠这种机制来实现函数重载的。 

> 被extern “C”修饰的函数或者变量是按照C语言方式编译和链接的，所以可以用一句话来概括extern “C”的真实目的：实现C\+\+与C的混合编程。


---
- 当C语言代码和C\+\+代码都使用C\+\+代码的编译器来编译，不会发生因符号改写带来的问题
- 但是，当C\+\+代码中引入c语言库时，就需要使用extern “c”解决问题，注意c语言不支持extern “c”


---

例：

```
#ifdef _CPlusPlus    // C语言不支持extern "C" 的语法
extern "c"           
{
#endif

#include "***.h"   // c 静态库的头文件 

#ifdef __CPlusPlus
}
#endif

```
