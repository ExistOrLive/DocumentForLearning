# 构造函数和析构函数 

## 构造函数

> 类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。`构造函数是用于为C++对象分配内存和初始化的`。

> 构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。

```c++

class Test
{
public :
	int a;
protected:
	int b;
private :
	int c;

public :
	Test();                        // 构造函数
	Test(const Test& obj);         // 拷贝构造函数
	
	~Test();                       // 析构函数
};

Test::Test()
{
	std::cout << "Test alloc" << std::endl;
	a = 1;
	b = 2;
	c = 3;
}

Test::Test(const Test& obj)
{
	a = obj.a + 12;
	b = obj.b;
	c = 100;
}

Test::~Test()
{
	std::cout << "Test dealloc" << std::endl;
}


```

### 默认构造函数

> 默认的构造函数没有任何的参数。 如上是Test类的定义， 其中Test() 就是默认的构造函数，函数的定义中实现了对象的初始化。

> `C++的类必须要有默认的构造函数。当没有显示定义任何构造函数时，系统会自动创建默认构造函数； 如果显示定义了任何一个构造函数，则必须显式定义默认构造函数。`

### 带参数的构造函数

> 构造函数可以重构。因此就会有的带参数的构造函数。带参数的构造函数可以使用初始化列表，初始化实例变量；也可以在函数体实现。`初始化列表的执行会在函数体中代码之前`

```c++

// 使用初始化列表初始化字段
Test::Test(int a, int b, int c):a(a),b(b),c(c)
{

}

// 不使用初始化列表
Test::Test(int a, int b, int c)
{
    this->a = a;
    this->b = b;
    this->c = c;
}
```

> 可以在构造函数中复用其他构造函数的代码

```c++

// 不使用初始化列表
Test::Test(int a, int b, int c)
{
    new (this)Test();   // 这里调用了默认构造函数的代码
    this->a = a;
    this->b = b;
    this->c = c;
}
```


### 拷贝构造函数

> 拷贝构造函数是一种特殊的构造函数，具有单个形参，该形参（常用const修饰）是对该类类型的引用。

``` C++ 

// 如上 Test::Test(const Test& obj) 就是拷贝构造函数

classname (const classname &obj) {
   // 构造函数的主体
}

```

> 当C++对象在变量间传递或者显示调用，就会调用拷贝构造函数。

> 当C++对象作为参数传递到函数中或者作为返回值返回时，也会调用拷贝构造函数（也就是C++对象在局部变量和形式参数间以及局部变量和临时变量间传递）

```C++

Test a;   // 隐式调用默认构造函数

Test b = a;        // 隐式调用拷贝构造函数
Test c = Test(a);  // 显示调用拷贝构造函数 

```

> 当C++对象在变量间传递就会调用拷贝构造函数，这样就会造成频繁的申请内存和销毁内存，很消耗资源。所有C++就引入了`引用`的概念

### 子类调用父类的构造函数

> 构造方法用来初始化类的对象，与父类的其它成员不同，它不能被子类继承（子类可以继承父类所有的成员变量和成员方法，但不继承父类的构造方法）

> 在创建子类对象时，为了初始化从父类继承来的数据成员，系统需要调用其父类的构造方法。如果没有显式的构造函数，编译器会给一个默认的构造函数，并且该默认的构造函数仅仅在没有显式地声明构造函数情况下创建。


1. 如果子类没有定义构造方法，则调用父类的无参数的构造方法。
2. 如果子类定义了构造方法，不论是无参数还是带参数，在创建子类的对象的时候,首先执行父类无参数的构造方法，然后执行自己的构造方法。
3. 在创建子类对象时候，如果子类的构造函数没有显示调用父类的构造函数，则会调用父类的默认无参构造函数。
4. 在创建子类对象时候，如果子类的构造函数没有显示调用父类的构造函数且父类自己提供了无参构造函数，则会调用父类自己的无参构造函数。
5. 在创建子类对象时候，如果子类的构造函数没有显示调用父类的构造函数且父类只定义了自己的有参构造函数，则会出错（如果父类只有有参数的构造方法，则子类必须显示调用此带参构造方法）。
6. 如果子类调用父类带参数的构造方法，需要用初始化父类成员对象的方式

> 总而言之，调用子类构造方法之前，一定要调用父类的构造方法。`子类构造方法没有显示调用父类构造方法时，系统会默认调用父类的无参构造方法；子类构造方法也可以显示调用父类的指定构造方法`