# 深度测试

## 1. 深度

- **深度**

      深度就是像素点在3D世界中距离观察者的距离，即 Z 值。

      深度值范围[0,1]
      

      深度就是Z值，Z轴的正方向垂直于屏幕向外


      当观察者在Z轴的正方向，Z值越大越靠近观察者
      当观察者在Z轴的负方向，Z值越小越靠近观察者

      一般来说，观察者面朝屏幕，在Z轴的正方向

- **深度缓冲区**

      深度缓冲区，就是一块显存内存区域，专门存储这每个像素点的深度值。

      深度缓冲区的中的深度值于帧缓冲区中的每一个像素一一对应

## 2. 案例[正背面剔除]缺口问题

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/2021-02-06-12-47-12.gif)

当甜甜圈旋转时，2个部分重叠时，OpenGL不能分清楚那个部分在前，那个部分在后。

上图的甜甜圈就是将理应被遮挡的部分绘制在前面。

## 3. 深度测试

**深度缓冲区** 和 **颜色缓冲区** 是对应的。**颜色缓冲区**存储像素的颜色信息，而**深度缓冲区**存储像素的深度信息。

在帧缓冲区绘制一个图层时，首先要将图层中的像素的深度值与当深度缓冲区中的值比较，如果大于深度缓冲区的值，则丢弃这部分；否则利用这个像素对应的深度值和颜色值，来分别更新深度缓冲区和颜色缓冲区。这个过程称为 **深度测试**

### 3.1 相关API

```c++
// 打开深度测试
glEnable(GL_DEPTH_TEST);

// 关闭深度测试
glDisable(GL_DEPTH_TEST);



/**
 * value:
 * GL_TRUE 开始深度缓冲区写入
 * GL_FALSE 关闭深度缓冲区写入
 **/
void glDepthMask(GLBool value);

// 指定深度测试判断模式
void glDepthFunc(GLEnum mode);

```

## 4. 深度测试的问题 Z-fighting(Z闪烁)

由于深度缓冲区精度的限制对于深度相差非常小的情况，OpenGL可能不能正确判断两者的深度，会导致深度测试的结果不可预测，显示出来的现象交错闪烁。

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-02-06%20%E4%B8%8B%E5%8D%882.48.19.png)

### 4.1 多边形偏移处理Z-Fighting

Z-Fighting 的 根本原因是 两个图层的深度值相差实在太小，导致OpenGL无法判断，所以解决办法就是在图层之间设置一个合适的间隔值，以保证OpenGL能够判断。

根据这个原理，OpenGL提出使用 **多边形偏移**

```c++
/**
 * 启动多边形偏移
 * GL_POLYGON_OFFSET_POINT 对应光栅化模式: GL_POINT 
 * GL_POLYGON_OFFSET_LINE 对应光栅化模式: GL_LINE 
 * GL_POLYGON_OFFSET_FILL 对应光栅化模式: GL_FILL 
 **/ 
glEnable(GL_POLYGON_OFFSET_FILL);


/**
 * 设置偏移量
 * 一般都设置 factor 和 units 为 -1 
 **/

void glPolygonOffset(GLfloat factor,GLfloat uniits);  
```

### 4.2 Z-Fighting 预防

- 手动设置偏移，避免两个物体靠得太近。 当然手动插入偏移代价较大

- 尽可能将近裁剪⾯设置得离观察者远⼀些。在近裁剪平⾯附近，深度的精确度是很⾼的，因此尽可能让近裁剪⾯远⼀些的话，会使整个裁剪范围内的精确度变⾼⼀些。但是这种⽅式会使离观察者较近的物体被裁减掉，因此需要调试好裁剪⾯参数。

- 使⽤更⾼位数的深度缓冲区，通常使⽤的深度缓冲区是24位的，现在有⼀些硬件使⽤使⽤32位的缓冲
