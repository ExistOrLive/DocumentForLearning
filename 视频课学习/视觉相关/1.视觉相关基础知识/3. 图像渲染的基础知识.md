# 图像渲染的基础知识

## 1. CPU和GPU的区别

- CPU 的 运算核心 和 控制核心
   
      不仅需要处理计算问题，还要处理逻辑控制问题。 

  ![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2020-12-16%20%E4%B8%8A%E5%8D%881.01.51.png)
  
- GPU 绘图运算专用处理器，由一个个独立的运算单元组成，支持高并发
  
       适用于逻辑简单，比较消耗运算能力的任务

       GPU在渲染流水线的中作用就是将CPU计算好的坐标，变换矩阵，向量等数学信息和纹理数据
       转换为一帧帧以像素为单位的可视化数据

  ![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2020-12-16%20%E4%B8%8A%E5%8D%881.05.52.png)

  
  
  我们所有的任务处理是以运行循环为基本单元来处理任务，比如说如果当前RunLoop在处理任务，你添加了一个任务，并不是说RunLoop就立马回来处理你的任务，而是这一趟搬运任务完成之后，再来搬运其他的任务~这里不是在即将休眠的时候才绘制，而且再当前的 beforeWaiting 添加了观察者，即将进入休眠的时候说明当前RunLoop是空闲的，所以唤醒他处理绘制任务。


## 2. 显示器的演变

- 随机扫描显示

- 光栅扫描显示

电子束逐行扫描

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2020-12-16%20%E4%B8%8A%E5%8D%881.17.15.png)


## 3. 常用光栅扫描显示器的结构

**显示控制器**：显示器中的硬件结构，控制显示器从**帧缓冲区**中读取帧数据并显示

**帧缓存** ： 也就是我们所说的显卡的内存，显存。保存由显卡处理过的或者即将提取的渲染数据。


![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2020-12-16%20%E4%B8%8A%E5%8D%881.29.34.png)


## 4. 屏幕显示图像的原理

> 屏幕显示的画面是由电子枪扫描一行一行的显示的；当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号(HSync); 当一帧画面显示完成后，电子枪复位，准备下一帧前，显示器会发出一个垂直同步信号(VSync)。显示器通常以固定的频率刷新，这个频率就是垂直同步信号产生的频率。

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E5%B1%8F%E5%B9%95%E6%98%BE%E5%83%8F%E5%8E%9F%E7%90%86.png)

> 如上图所示，计算机系统中 CPU、GPU、显示器是以上面这种方式协同工作的。CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。


### 4.1 画面撕裂问题

为了解决效率问题，通常会引入两个缓冲区，即双缓冲机制；在这种情况下，GPU 会预先渲染好一帧放入一个缓冲区内，让视频控制器读取，当下一帧渲染好后，GPU 会直接把视频控制器的指针指向第二个缓冲器。如此一来效率会有很大的提升；但是因此会引入**画面撕裂**的问题，如下图。

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/ios_vsync_off.jpg)

为了解决画面撕裂，，GPU 通常有一个机制叫做垂直同步（简写也是 V-Sync），当开启垂直同步后，GPU 会等待显示器的 VSync 信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。

引入**垂直同步机制**后，GPU要等到收到垂直同步信号，才会渲染下一帧。一定程度上拖慢了CPU/GPU渲染的速度。

## 4.2 掉帧/卡顿问题

显示器以固定的频率刷新画面，如果CPU/GPU不能及时地将渲染好的帧数据放入帧缓存中，显示器就会重复的刷新同一块帧数据。这种情况称为**掉帧**。

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2020-12-16%20%E4%B8%8A%E5%8D%882.00.19.png)

**掉帧的原因**：

- CPU/GPU渲染流水线过长

- 引入垂直同步拖慢GPU渲染的速度，可能会造成掉帧。


## 5. Core Animation 流水线

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/ios-core-animation-pipeline-steps.png)


## 6. 离屏渲染

## 4. 常见的触发离屏渲染的场景

1. 使⽤了 mask 的 layer (layer.mask)
2. 需要进⾏裁剪的 layer (layer.masksToBounds / view.clipsToBounds)
3. 设置了组透明度为 YES，并且透明度不为 1 的 layer (layer.allowsGroupOpacity/
layer.opacity)
4. 添加了投影的 layer (layer.shadow*)
5. 采⽤了光栅化的 layer (layer.shouldRasterize)
6. 绘制了⽂字的 layer (UILabel, CATextLayer, Core Text 等)