# 类的加载下

## 1. 分类中的Mach-O结构

**分类的加载** 本质上是将**分类**中定义的**方法**，**属性** 以及 **实现的协议** 加入到运行时的 **类对象中**。

如果原始**类**和其**分类**在同一个库中，那么在编译时就可能会优化，将**分类**中的数据直接加入**类**数据中。

```objc 
// 定义如下的类和分类
@interface LGPerson : NSObject
- (void) sayHello3;
- (void) sayHello1;
- (void) sayHello;
@property(nonatomic, strong) NSString *name;
@end

@implementation LGPerson
- (void)sayHello3{    
}
- (void)sayHello{
}
- (void)sayHello1{
}
@end


@interface LGPerson (LGA)
- (void) LGA;
@end

@implementation LGPerson (LGA)
- (void) LGA{
}
@end

```

可以在 Mach-O 文件中看到， `LGPerson` 类数据中已经包含了分类中的方法, 对于这样的分类在加载时只需要加载类的信息。

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-06-05%20%E4%B8%8A%E5%8D%883.02.01.png)

```objc 
// 定义如下的类和分类
// 类和分类都实现 +load 方法
@interface LGPerson : NSObject
- (void) sayHello3;
- (void) sayHello1;
- (void) sayHello;
@property(nonatomic, strong) NSString *name;
@end

@implementation LGPerson
+ (void) load{
}
- (void)sayHello3{    
}
- (void)sayHello{
}
- (void)sayHello1{
}
@end


@interface LGPerson (LGA)
- (void) LGA;
@end

@implementation LGPerson (LGA)
+ (void) load{
}
- (void) LGA{
}
@end

```

可以在 Mach-O 文件中看到， `LGPerson` 类数据中没有包含了分类`LGA`中的方法; 而分类`LGA`信息在 **__objc_catlist** 段中。
对于这样的分类，再加载完类信息之后还需要加载分类信息。

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-06-05%20%E4%B8%8A%E5%8D%883.33.08.png)

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-06-05%20%E4%B8%8A%E5%8D%883.33.37.png)

在同一个库中，尽管有些分类的信息会编译在类的信息中；但是考虑到**类**和**分类**在不同库中的情况，其实在加载分类才是相对重要需要研究的部分。

## 2. 分类加载进内存

想要加载**分类**，则必须先要加载**类**。而在工程中，一个**类**和**分类**往往分布在不同的动态库中，且动态库的载入顺序并不确定。因此 **分类的加载** 是在所有的 **类** 都加载进内存之后。

分类的加载被推迟到了首次调用`load_Images` 函数中, 此时所有动态库的类信息都已经加载进内存中。  `loadAllCategories()` 将会加载所有动态库中的所有**分类**信息。如果**分类**的**类**已经realize，则将分类的数据合并到类中； 如果**分类**的**类**没有realize，则讲分类信息添加得到表`unattchCategories`中。

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-06-05%20%E4%B8%8B%E5%8D%8812.58.03.png)

```c++ 

attachCategories()/objc::unattachedCategories.addForClass() 
processCatlist()
loadCategories_nolock()     // 遍历某个动态库中的category列表
loadAllCategories()         // 遍历动态库
load_Images()
```

```c++ 

static void load_categories_nolock(header_info *hi) {
    bool hasClassProperties = hi->info()->hasCategoryClassProperties();

    size_t count;
    auto processCatlist = [&](category_t * const *catlist) {

        for (unsigned i = 0; i < count; i++) {
            category_t *cat = catlist[i];
            Class cls = remapClass(cat->cls);
            locstamped_category_t lc{cat, hi};

            if (!cls) {
                // Category's target class is missing (probably weak-linked).
                // Ignore the category.
                continue;
            }
            
            .....

             // 如果 cls 已经 realize，则将分类信息合并到类中
            if (cls->isRealized()) {
                attachCategories(cls, &lc, 1, ATTACH_EXISTING);
            } else {
                // 否则将分类信息保存在表中
                objc::unattachedCategories.addForClass(lc, cls);
            }        
            
            .......

        }
    };

    processCatlist(hi->catlist(&count));
    processCatlist(hi->catlist2(&count));
}

```

### 2.1  attachCategories (合并分类信息到类中)

分类中的信息并不会修改类信息的原始结构`class_ro_t`; 而是会创建`class_rw_ext_t`结构作为 **dirty page**, 来保存类和分类中的方法，属性和协议。

`class_rw_ext_t` 以 `method_array_t` ,`property_array_t` 和 `protocol_array_t` 的结构保存 方法，属性和协议， 元素类型为 `method_list_t`, `property_list_t` 和 `protocol_list_t`


```c++ 
static void
attachCategories(Class cls, const locstamped_category_t *cats_list, uint32_t cats_count,
                 int flags)
{
    // 建立长度为 64 的 方法缓存，属性缓存 和 协议缓存
    constexpr uint32_t ATTACH_BUFSIZ = 64;
    method_list_t   *mlists[ATTACH_BUFSIZ];
    property_list_t *proplists[ATTACH_BUFSIZ];
    protocol_list_t *protolists[ATTACH_BUFSIZ];

    uint32_t mcount = 0;
    uint32_t propcount = 0;
    uint32_t protocount = 0;
    bool fromBundle = NO;
    bool isMeta = (flags & ATTACH_METACLASS);
    // 如果class_rw_ext_t 结构不存在，就创建
    auto rwe = cls->data()->extAllocIfNeeded();

    for (uint32_t i = 0; i < cats_count; i++) {
        auto& entry = cats_list[i];

        method_list_t *mlist = entry.cat->methodsForMeta(isMeta);
        if (mlist) {
            if (mcount == ATTACH_BUFSIZ) {
                prepareMethodLists(cls, mlists, mcount, NO, fromBundle, __func__);
                rwe->methods.attachLists(mlists, mcount);
                mcount = 0;
            }
            mlists[ATTACH_BUFSIZ - ++mcount] = mlist;
            fromBundle |= entry.hi->isBundle();
        }

        property_list_t *proplist =
            entry.cat->propertiesForMeta(isMeta, entry.hi);
        if (proplist) {
            if (propcount == ATTACH_BUFSIZ) {
                rwe->properties.attachLists(proplists, propcount);
                propcount = 0;
            }
            proplists[ATTACH_BUFSIZ - ++propcount] = proplist;
        }

        protocol_list_t *protolist = entry.cat->protocolsForMeta(isMeta);
        if (protolist) {
            if (protocount == ATTACH_BUFSIZ) {
                rwe->protocols.attachLists(protolists, protocount);
                protocount = 0;
            }
            protolists[ATTACH_BUFSIZ - ++protocount] = protolist;
        }
    }

    if (mcount > 0) {
        prepareMethodLists(cls, mlists + ATTACH_BUFSIZ - mcount, mcount,
                           NO, fromBundle, __func__);
        rwe->methods.attachLists(mlists + ATTACH_BUFSIZ - mcount, mcount);
        if (flags & ATTACH_EXISTING) {
            flushCaches(cls, __func__, [](Class c){
                // constant caches have been dealt with in prepareMethodLists
                // if the class still is constant here, it's fine to keep
                return !c->cache.isConstantOptimizedCache();
            });
        }
    }

    rwe->properties.attachLists(proplists + ATTACH_BUFSIZ - propcount, propcount);

    rwe->protocols.attachLists(protolists + ATTACH_BUFSIZ - protocount, protocount);
}

```

以方法为例， 在 `class_rw_ext_t` 以`method_array_t` 结构保存。 类和分类中的方法列表以 `method_list_t` 结构保存，

`method_array_t` 保存的就是 `method_list_t`的指针，并且后合并的分类方法插在前面。

```c++ 

```

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/attachCategories.png)


## 2.2 objc::unattachedCategories.addForClass()

对于类没有realize的分类，需要保存到列表中`unattachCategories`

```c++ 
    
    // 用于保存分类的信息
    static UnattachedCategories unattachedCategories;

    void addForClass(locstamped_category_t lc, Class cls)
    {
        runtimeLock.assertLocked();

        if (slowpath(PrintConnecting)) {
            _objc_inform("CLASS: found category %c%s(%s)",
                         cls->isMetaClassMaybeUnrealized() ? '+' : '-',
                         cls->nameForLogging(), lc.cat->name);
        }

        auto result = get().try_emplace(cls, lc);
        if (!result.second) {
            result.first->second.append(lc);
        }
    }

```

等到类realize之后，再合并分类信息，`attachToClass` 会在 `realizeClassWithoutSwift` 中调用。

```c++ 
attachCategories()
attachToClass()
methodizeClass()
realizeClassWithoutSwift().     


    void attachToClass(Class cls, Class previously, int flags)
    {
        runtimeLock.assertLocked();
        ASSERT((flags & ATTACH_CLASS) ||
               (flags & ATTACH_METACLASS) ||
               (flags & ATTACH_CLASS_AND_METACLASS));

        auto &map = get();
        auto it = map.find(previously);

        if (it != map.end()) {
            category_list &list = it->second;
            if (flags & ATTACH_CLASS_AND_METACLASS) {
                int otherFlags = flags & ~ATTACH_CLASS_AND_METACLASS;
                attachCategories(cls, list.array(), list.count(), otherFlags | ATTACH_CLASS);
                attachCategories(cls->ISA(), list.array(), list.count(), otherFlags | ATTACH_METACLASS);
            } else {
                attachCategories(cls, list.array(), list.count(), flags);
            }
            map.erase(it);
        }
    }



```

