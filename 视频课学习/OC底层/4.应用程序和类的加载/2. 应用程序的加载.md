# 应用程序的加载

## 1. 执行应用程序

应用程序的执行是由系统进程调用`fork`函数，创建一个新的进程。再调用`execve`函数或者其衍生函数，在该进程的地址空间中执行 `Mach-O` 文件。

当我们调用`execve`（程序加载器）内核实际上在执行以下操作：
- 将Mach-O文件映射到内存中
- 开始分析Mach-O中的mach_header，以确认它是有效的Mach-O文件

## 2. 虚拟内存 

我们知道一般来说 **逻辑地址空间** 会远大于 **物理地址空间(物理内存)**。 iOS/MacOS 采用了基于段页式内存管理的虚拟内存技术，带来以下几点优势：

- 将部分磁盘空间映射到逻辑地址空间，扩大了内存空间
  
      在访问某个页时，该页不在内存中，就会发生缺页中断，将该页调入内存。
      如果此时内存不够，还需要将某个暂时不用访问的页调出内存。如果该页被修改过，则需要该页覆盖到磁盘的交换区中，如果没有修改则可以直接释放。


- 将同一个物理内存页映射到多个进程的逻辑地址空间中，实现共享内存。 
  
      对于一些共用动态库dylib，可以使用共享内存页的方式在多个进程之间共享

- 基于文件的映射，将文件映射到虚拟内存，而不是直接将整个文件读入内存。在访问文件的某个页时，发出缺页中断将对应页调入内存

       对于Mach-O文件的加载，也是先将文件映射到虚拟内存中，
       按需将页调入内存，必要时也会将页调出内存。

- Dirty Page / Clean Page 

      对于共享的动态库，如果已经载入内存，在另一个程序启动时，就可以直接使用。

      Mach-O文件中 _TEXT段是不可以修改的，可以直接使用，称为 Clean Page。即便在某个时刻调出内存，可以直接释放出空间，需要时再调入内存即可

      _DATA段是数据段，在载入内存后是可以被修改的，对于新的程序不一定可以直接使用，需要从磁盘中加载。在调出内存时，也需要覆盖到磁盘中。
      被修改后的页称为dirty page 

      因此 Dirty Page 的维护代价是大于Clean Page

- Copy-On-Write 

       对于共享库的_DATA段，采用Copy-On-Write技术,
       修改时，才会复制对应的页。

- 权限管理 
       
       _TEXT段 r-w
       _DATA段 rw-
       _LINKEDIT段 r--

## 3. 在虚拟内存中加载运行程序

1. 进程1执行某个Mach-O文件，首先将Mach-O文件映射(`mmap()`)到虚拟内存中，并没有直接加载进内存。
   
   ![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-05-27%20%E4%B8%8A%E5%8D%884.26.38.png)

2. 试图读取 **Mach-O Header**，但是对应页并不在物理内存中，发出缺页中断将对应页调入内存。

    ![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-05-27%20%E4%B8%8A%E5%8D%884.26.47.png)

3. **Mach-O Header** 告诉我们需要读取 `_LINKEDIT`段，再次发出缺页中断调用对应页

    ![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-05-27%20%E4%B8%8A%E5%8D%884.26.55.png)

4. 之后需要对`_DATA`段处理，则调入对应的页，并修改了部分数据，此时 `_DATA`段的页为 Dirty Page。

    ![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-05-27%20%E4%B8%8A%E5%8D%884.27.02.png)

    ![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-05-27%20%E4%B8%8A%E5%8D%884.27.09.png)

5. 进程2也执行同一个Mach-O文件。此时，进程1加载进内存中的Clean Page 可以直接使用，而 Dirty Page 只需要重新从磁盘中加载 

    ![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-05-27%20%E4%B8%8A%E5%8D%884.27.34.png)

6. 进程1和进程2共享Clean Page。在进程2中，可以正常修改`_DATA`段的页，与进程1中的，`_DATA`段是两块不同的内存。

    ![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-05-27%20%E4%B8%8A%E5%8D%884.27.48.png)

7. 在程序加载和初始化结束后，`_LINKEDIT`段可以被回收

    ![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-05-27%20%E4%B8%8A%E5%8D%884.27.59.png)


在程序的加载和执行阶段，将执行文件映射到虚拟内存中，而非将整个文件读入内存，仅将当前需要的页加载至内存中。

在多个进程的情况下，可以共享内存的Clean Page，对于Dirty Page 采用 Copy on Write 机制。


## 4. ASLR 和 Code Signature

**ASLR(Address Space Layout Randomization)** 地址空间布局随机化，是一种防范内存损坏漏洞被利用的计算机安全技术。
    
    Mach-O文件加载起始地址都是随机的。

**Code Signature(代码签名)** 是一种确保代码可靠性的安全技术。 对于 Mach-O 文件每一页都计算加密hash，结果保存在 _LINKEDIT段中。


## 5. Dyld 加载应用程序

早期的程序很简单，只需要映射进内存后，从其实地址开始执行就可以了。但是现在的程序变得复杂了很多，都会依赖许多动态库。那么如何加载和链接依赖的动态库就是一个需要解决的问题。

Apple的系统使用**Dyld动态链接器**，在其他Unix系统上通常称为**ld.so**



- **加载所有的动态库**
         
        解析依赖的动态库列表
        找到并加载动态库的头
        验证Mach-O文件和代码签名
        调用mmap()映射进内存

        通常App会加载100～400个动态库
        大部分为系统动态库，系统动态库的加载已经经过优化
           
        
  ![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-05-27%20%E4%B8%8A%E5%8D%885.44.21.png)
      
- **修改基址Rebasing**
     
     程序或者dylib加载起始地址是随机的。在编译时，Mach-O文件中保存的指针都是相对的；在加载时 加上一个 **起始地址(滑动地址)**

       代码签名意味着_TEXT段是不可以被修改的
       现代的代码签名使用 dynamic PIC(Position Independent Code)
       代码中使用的动态地址，可以在任何地址执行
       而实际的地址保存在_DATA段中，
       在Mach-O文件加载时修正，加上滑动地址

     
     需要变基的指针保存在_DATA段中，它们的地址保存在_LINKEDIT段中

     修改基址(Rebasing)修复的是镜像内的指针，绑定(Binding)则修复的是指向其他镜像的指针

- **绑定(Binding)**
  
   绑定(Binding) 修复的是指向外部动态库(镜像)的指针。
   在Mach-O文件中，指向外部的指针保存为符号。在绑定时，修正为符号在内存中的实际地址。

       如 malloc 符号，需要找到实现在内存的地址

- **Notify Objc Runtime**
  
    Objc作为一门动态语言，在运行之前，需要进行一些准备操作。

       维护一张OC类表，并注册所有的OC类名字和类对象
       优化OC类的ivar布局,避免脆弱的基类问题(Non-fragile ivar offsets updated)
       将分类中的方法加入方法列表
       保证唯一选择器

- **initializers**

        执行C++函数 __attribute__((constructor))

        调用Objc的+load方法

        调用main函数

dyld是一个辅助程序：

- 加载所有的依赖动态库
- 修正_DATA段中的指针
- 初始化依赖库

## 6. Tip

###  6.1 脆弱的基类问题

在C++语言中，存在一种脆弱的基类问题。对于C++类中的变量，它们的偏移量在编译时静态确定，运行时不会修改。

如果基类在某个动态库中，动态库升级了并增加了一个变量。而此时一个依赖该动态库的可执行文件没有重新编译直接运行，会通过原本的偏移量访问变量，那么此时运行结果将不可知。

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-05-27%20%E4%B8%8B%E5%8D%882.55.55.png)


在OC中，加载类时，会更新类的内存布局，以适应动态库的更新。这就是为啥iOS系统不断升级，但是旧的app仍可以运行。

### 6.2 xcrun dyldinfo 查看 mach-o文件信息

```sh 
# 查看mach-o文件中rebasing和binding的地址
xcrun dyldinfo -rebase -bind -lazy_bind /Users/zhumeng/Desktop/TestFramework
```

![](https://gitee.com/existorlive/exist-or-live-pic/raw/master/%E6%88%AA%E5%B1%8F2021-05-27%20%E4%B8%8B%E5%8D%883.00.34.png)




      
       











